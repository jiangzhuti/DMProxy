// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CommunicationData.proto

#ifndef PROTOBUF_CommunicationData_2eproto__INCLUDED
#define PROTOBUF_CommunicationData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace qihoo {
namespace protocol {
namespace messages {
class Ack;
class AckDefaultTypeInternal;
extern AckDefaultTypeInternal _Ack_default_instance_;
class ChatReq;
class ChatReqDefaultTypeInternal;
extern ChatReqDefaultTypeInternal _ChatReq_default_instance_;
class ChatResp;
class ChatRespDefaultTypeInternal;
extern ChatRespDefaultTypeInternal _ChatResp_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class Ex1QueryUserStatusReq;
class Ex1QueryUserStatusReqDefaultTypeInternal;
extern Ex1QueryUserStatusReqDefaultTypeInternal _Ex1QueryUserStatusReq_default_instance_;
class Ex1QueryUserStatusResp;
class Ex1QueryUserStatusRespDefaultTypeInternal;
extern Ex1QueryUserStatusRespDefaultTypeInternal _Ex1QueryUserStatusResp_default_instance_;
class GetInfoReq;
class GetInfoReqDefaultTypeInternal;
extern GetInfoReqDefaultTypeInternal _GetInfoReq_default_instance_;
class GetInfoResp;
class GetInfoRespDefaultTypeInternal;
extern GetInfoRespDefaultTypeInternal _GetInfoResp_default_instance_;
class GetMultiInfosReq;
class GetMultiInfosReqDefaultTypeInternal;
extern GetMultiInfosReqDefaultTypeInternal _GetMultiInfosReq_default_instance_;
class GetMultiInfosResp;
class GetMultiInfosRespDefaultTypeInternal;
extern GetMultiInfosRespDefaultTypeInternal _GetMultiInfosResp_default_instance_;
class Info;
class InfoDefaultTypeInternal;
extern InfoDefaultTypeInternal _Info_default_instance_;
class InitLoginReq;
class InitLoginReqDefaultTypeInternal;
extern InitLoginReqDefaultTypeInternal _InitLoginReq_default_instance_;
class InitLoginResp;
class InitLoginRespDefaultTypeInternal;
extern InitLoginRespDefaultTypeInternal _InitLoginResp_default_instance_;
class LoginReq;
class LoginReqDefaultTypeInternal;
extern LoginReqDefaultTypeInternal _LoginReq_default_instance_;
class LoginResp;
class LoginRespDefaultTypeInternal;
extern LoginRespDefaultTypeInternal _LoginResp_default_instance_;
class LogoutReq;
class LogoutReqDefaultTypeInternal;
extern LogoutReqDefaultTypeInternal _LogoutReq_default_instance_;
class LogoutResp;
class LogoutRespDefaultTypeInternal;
extern LogoutRespDefaultTypeInternal _LogoutResp_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class NewMessageNotify;
class NewMessageNotifyDefaultTypeInternal;
extern NewMessageNotifyDefaultTypeInternal _NewMessageNotify_default_instance_;
class Notify;
class NotifyDefaultTypeInternal;
extern NotifyDefaultTypeInternal _Notify_default_instance_;
class Pair;
class PairDefaultTypeInternal;
extern PairDefaultTypeInternal _Pair_default_instance_;
class Proxy;
class ProxyDefaultTypeInternal;
extern ProxyDefaultTypeInternal _Proxy_default_instance_;
class ReConnectNotify;
class ReConnectNotifyDefaultTypeInternal;
extern ReConnectNotifyDefaultTypeInternal _ReConnectNotify_default_instance_;
class ReLoginNotify;
class ReLoginNotifyDefaultTypeInternal;
extern ReLoginNotifyDefaultTypeInternal _ReLoginNotify_default_instance_;
class ReqEQ1User;
class ReqEQ1UserDefaultTypeInternal;
extern ReqEQ1UserDefaultTypeInternal _ReqEQ1User_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RespEQ1User;
class RespEQ1UserDefaultTypeInternal;
extern RespEQ1UserDefaultTypeInternal _RespEQ1User_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class RouteInfo;
class RouteInfoDefaultTypeInternal;
extern RouteInfoDefaultTypeInternal _RouteInfo_default_instance_;
class Service_Req;
class Service_ReqDefaultTypeInternal;
extern Service_ReqDefaultTypeInternal _Service_Req_default_instance_;
class Service_Resp;
class Service_RespDefaultTypeInternal;
extern Service_RespDefaultTypeInternal _Service_Resp_default_instance_;
class User;
class UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace messages
}  // namespace protocol
}  // namespace qihoo

namespace qihoo {
namespace protocol {
namespace messages {

namespace protobuf_CommunicationData_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_CommunicationData_2eproto

// ===================================================================

class Pair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.Pair) */ {
 public:
  Pair();
  virtual ~Pair();

  Pair(const Pair& from);

  inline Pair& operator=(const Pair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pair& default_instance();

  static inline const Pair* internal_default_instance() {
    return reinterpret_cast<const Pair*>(
               &_Pair_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Pair* other);

  // implements Message ----------------------------------------------

  inline Pair* New() const PROTOBUF_FINAL { return New(NULL); }

  Pair* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pair& from);
  void MergeFrom(const Pair& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional bytes value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Pair)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Error* other);

  // implements Message ----------------------------------------------

  inline Error* New() const PROTOBUF_FINAL { return New(NULL); }

  Error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes description = 2;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const void* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // required uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Error)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_description();
  void clear_has_description();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::uint32 id_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.User) */ {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(User* other);

  // implements Message ----------------------------------------------

  inline User* New() const PROTOBUF_FINAL { return New(NULL); }

  User* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(User* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qihoo.protocol.messages.Pair property_pairs = 2;
  int property_pairs_size() const;
  void clear_property_pairs();
  static const int kPropertyPairsFieldNumber = 2;
  const ::qihoo::protocol::messages::Pair& property_pairs(int index) const;
  ::qihoo::protocol::messages::Pair* mutable_property_pairs(int index);
  ::qihoo::protocol::messages::Pair* add_property_pairs();
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >*
      mutable_property_pairs();
  const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >&
      property_pairs() const;

  // required string userid = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUseridFieldNumber = 1;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.User)
 private:
  void set_has_userid();
  void clear_has_userid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair > property_pairs_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.Info) */ {
 public:
  Info();
  virtual ~Info();

  Info(const Info& from);

  inline Info& operator=(const Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Info& default_instance();

  static inline const Info* internal_default_instance() {
    return reinterpret_cast<const Info*>(
               &_Info_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Info* other);

  // implements Message ----------------------------------------------

  inline Info* New() const PROTOBUF_FINAL { return New(NULL); }

  Info* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Info& from);
  void MergeFrom(const Info& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qihoo.protocol.messages.Pair property_pairs = 1;
  int property_pairs_size() const;
  void clear_property_pairs();
  static const int kPropertyPairsFieldNumber = 1;
  const ::qihoo::protocol::messages::Pair& property_pairs(int index) const;
  ::qihoo::protocol::messages::Pair* mutable_property_pairs(int index);
  ::qihoo::protocol::messages::Pair* add_property_pairs();
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >*
      mutable_property_pairs();
  const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >&
      property_pairs() const;

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Info)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair > property_pairs_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.LoginReq) */ {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReq& default_instance();

  static inline const LoginReq* internal_default_instance() {
    return reinterpret_cast<const LoginReq*>(
               &_LoginReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(LoginReq* other);

  // implements Message ----------------------------------------------

  inline LoginReq* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mobile_type = 1;
  bool has_mobile_type() const;
  void clear_mobile_type();
  static const int kMobileTypeFieldNumber = 1;
  const ::std::string& mobile_type() const;
  void set_mobile_type(const ::std::string& value);
  #if LANG_CXX11
  void set_mobile_type(::std::string&& value);
  #endif
  void set_mobile_type(const char* value);
  void set_mobile_type(const char* value, size_t size);
  ::std::string* mutable_mobile_type();
  ::std::string* release_mobile_type();
  void set_allocated_mobile_type(::std::string* mobile_type);

  // required string server_ram = 3;
  bool has_server_ram() const;
  void clear_server_ram();
  static const int kServerRamFieldNumber = 3;
  const ::std::string& server_ram() const;
  void set_server_ram(const ::std::string& value);
  #if LANG_CXX11
  void set_server_ram(::std::string&& value);
  #endif
  void set_server_ram(const char* value);
  void set_server_ram(const char* value, size_t size);
  ::std::string* mutable_server_ram();
  ::std::string* release_server_ram();
  void set_allocated_server_ram(::std::string* server_ram);

  // optional bytes secret_ram = 4;
  bool has_secret_ram() const;
  void clear_secret_ram();
  static const int kSecretRamFieldNumber = 4;
  const ::std::string& secret_ram() const;
  void set_secret_ram(const ::std::string& value);
  #if LANG_CXX11
  void set_secret_ram(::std::string&& value);
  #endif
  void set_secret_ram(const char* value);
  void set_secret_ram(const void* value, size_t size);
  ::std::string* mutable_secret_ram();
  ::std::string* release_secret_ram();
  void set_allocated_secret_ram(::std::string* secret_ram);

  // optional string deviceid = 7;
  bool has_deviceid() const;
  void clear_deviceid();
  static const int kDeviceidFieldNumber = 7;
  const ::std::string& deviceid() const;
  void set_deviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_deviceid(::std::string&& value);
  #endif
  void set_deviceid(const char* value);
  void set_deviceid(const char* value, size_t size);
  ::std::string* mutable_deviceid();
  ::std::string* release_deviceid();
  void set_allocated_deviceid(::std::string* deviceid);

  // optional string platform = 8;
  bool has_platform() const;
  void clear_platform();
  static const int kPlatformFieldNumber = 8;
  const ::std::string& platform() const;
  void set_platform(const ::std::string& value);
  #if LANG_CXX11
  void set_platform(::std::string&& value);
  #endif
  void set_platform(const char* value);
  void set_platform(const char* value, size_t size);
  ::std::string* mutable_platform();
  ::std::string* release_platform();
  void set_allocated_platform(::std::string* platform);

  // optional string verf_code = 9;
  bool has_verf_code() const;
  void clear_verf_code();
  static const int kVerfCodeFieldNumber = 9;
  const ::std::string& verf_code() const;
  void set_verf_code(const ::std::string& value);
  #if LANG_CXX11
  void set_verf_code(::std::string&& value);
  #endif
  void set_verf_code(const char* value);
  void set_verf_code(const char* value, size_t size);
  ::std::string* mutable_verf_code();
  ::std::string* release_verf_code();
  void set_allocated_verf_code(::std::string* verf_code);

  // required uint32 net_type = 2;
  bool has_net_type() const;
  void clear_net_type();
  static const int kNetTypeFieldNumber = 2;
  ::google::protobuf::uint32 net_type() const;
  void set_net_type(::google::protobuf::uint32 value);

  // optional bool not_encrypt = 10;
  bool has_not_encrypt() const;
  void clear_not_encrypt();
  static const int kNotEncryptFieldNumber = 10;
  bool not_encrypt() const;
  void set_not_encrypt(bool value);

  // optional uint32 app_id = 5 [default = 2000];
  bool has_app_id() const;
  void clear_app_id();
  static const int kAppIdFieldNumber = 5;
  ::google::protobuf::uint32 app_id() const;
  void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 heart_feq = 6 [default = 300];
  bool has_heart_feq() const;
  void clear_heart_feq();
  static const int kHeartFeqFieldNumber = 6;
  ::google::protobuf::uint32 heart_feq() const;
  void set_heart_feq(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.LoginReq)
 private:
  void set_has_mobile_type();
  void clear_has_mobile_type();
  void set_has_net_type();
  void clear_has_net_type();
  void set_has_server_ram();
  void clear_has_server_ram();
  void set_has_secret_ram();
  void clear_has_secret_ram();
  void set_has_app_id();
  void clear_has_app_id();
  void set_has_heart_feq();
  void clear_has_heart_feq();
  void set_has_deviceid();
  void clear_has_deviceid();
  void set_has_platform();
  void clear_has_platform();
  void set_has_verf_code();
  void clear_has_verf_code();
  void set_has_not_encrypt();
  void clear_has_not_encrypt();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr mobile_type_;
  ::google::protobuf::internal::ArenaStringPtr server_ram_;
  ::google::protobuf::internal::ArenaStringPtr secret_ram_;
  ::google::protobuf::internal::ArenaStringPtr deviceid_;
  ::google::protobuf::internal::ArenaStringPtr platform_;
  ::google::protobuf::internal::ArenaStringPtr verf_code_;
  ::google::protobuf::uint32 net_type_;
  bool not_encrypt_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 heart_feq_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.LoginResp) */ {
 public:
  LoginResp();
  virtual ~LoginResp();

  LoginResp(const LoginResp& from);

  inline LoginResp& operator=(const LoginResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResp& default_instance();

  static inline const LoginResp* internal_default_instance() {
    return reinterpret_cast<const LoginResp*>(
               &_LoginResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(LoginResp* other);

  // implements Message ----------------------------------------------

  inline LoginResp* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginResp& from);
  void MergeFrom(const LoginResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string session_id = 2;
  bool has_session_id() const;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // required string session_key = 3;
  bool has_session_key() const;
  void clear_session_key();
  static const int kSessionKeyFieldNumber = 3;
  const ::std::string& session_key() const;
  void set_session_key(const ::std::string& value);
  #if LANG_CXX11
  void set_session_key(::std::string&& value);
  #endif
  void set_session_key(const char* value);
  void set_session_key(const char* value, size_t size);
  ::std::string* mutable_session_key();
  ::std::string* release_session_key();
  void set_allocated_session_key(::std::string* session_key);

  // optional string client_login_ip = 4;
  bool has_client_login_ip() const;
  void clear_client_login_ip();
  static const int kClientLoginIpFieldNumber = 4;
  const ::std::string& client_login_ip() const;
  void set_client_login_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_client_login_ip(::std::string&& value);
  #endif
  void set_client_login_ip(const char* value);
  void set_client_login_ip(const char* value, size_t size);
  ::std::string* mutable_client_login_ip();
  ::std::string* release_client_login_ip();
  void set_allocated_client_login_ip(::std::string* client_login_ip);

  // optional string serverip = 5;
  bool has_serverip() const;
  void clear_serverip();
  static const int kServeripFieldNumber = 5;
  const ::std::string& serverip() const;
  void set_serverip(const ::std::string& value);
  #if LANG_CXX11
  void set_serverip(::std::string&& value);
  #endif
  void set_serverip(const char* value);
  void set_serverip(const char* value, size_t size);
  ::std::string* mutable_serverip();
  ::std::string* release_serverip();
  void set_allocated_serverip(::std::string* serverip);

  // required uint32 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.LoginResp)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_session_id();
  void clear_has_session_id();
  void set_has_session_key();
  void clear_has_session_key();
  void set_has_client_login_ip();
  void clear_has_client_login_ip();
  void set_has_serverip();
  void clear_has_serverip();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::google::protobuf::internal::ArenaStringPtr session_key_;
  ::google::protobuf::internal::ArenaStringPtr client_login_ip_;
  ::google::protobuf::internal::ArenaStringPtr serverip_;
  ::google::protobuf::uint32 timestamp_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChatReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.ChatReq) */ {
 public:
  ChatReq();
  virtual ~ChatReq();

  ChatReq(const ChatReq& from);

  inline ChatReq& operator=(const ChatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatReq& default_instance();

  static inline const ChatReq* internal_default_instance() {
    return reinterpret_cast<const ChatReq*>(
               &_ChatReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ChatReq* other);

  // implements Message ----------------------------------------------

  inline ChatReq* New() const PROTOBUF_FINAL { return New(NULL); }

  ChatReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChatReq& from);
  void MergeFrom(const ChatReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChatReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes body = 1;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 1;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  #if LANG_CXX11
  void set_body(::std::string&& value);
  #endif
  void set_body(const char* value);
  void set_body(const void* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // optional bytes m_parameter = 6;
  bool has_m_parameter() const;
  void clear_m_parameter();
  static const int kMParameterFieldNumber = 6;
  const ::std::string& m_parameter() const;
  void set_m_parameter(const ::std::string& value);
  #if LANG_CXX11
  void set_m_parameter(::std::string&& value);
  #endif
  void set_m_parameter(const char* value);
  void set_m_parameter(const void* value, size_t size);
  ::std::string* mutable_m_parameter();
  ::std::string* release_m_parameter();
  void set_allocated_m_parameter(::std::string* m_parameter);

  // optional bytes s_parameter = 8;
  bool has_s_parameter() const;
  void clear_s_parameter();
  static const int kSParameterFieldNumber = 8;
  const ::std::string& s_parameter() const;
  void set_s_parameter(const ::std::string& value);
  #if LANG_CXX11
  void set_s_parameter(::std::string&& value);
  #endif
  void set_s_parameter(const char* value);
  void set_s_parameter(const void* value, size_t size);
  ::std::string* mutable_s_parameter();
  ::std::string* release_s_parameter();
  void set_allocated_s_parameter(::std::string* s_parameter);

  // optional uint32 body_id = 2;
  bool has_body_id() const;
  void clear_body_id();
  static const int kBodyIdFieldNumber = 2;
  ::google::protobuf::uint32 body_id() const;
  void set_body_id(::google::protobuf::uint32 value);

  // optional uint32 more_flag = 3;
  bool has_more_flag() const;
  void clear_more_flag();
  static const int kMoreFlagFieldNumber = 3;
  ::google::protobuf::uint32 more_flag() const;
  void set_more_flag(::google::protobuf::uint32 value);

  // required uint32 body_type = 4;
  bool has_body_type() const;
  void clear_body_type();
  static const int kBodyTypeFieldNumber = 4;
  ::google::protobuf::uint32 body_type() const;
  void set_body_type(::google::protobuf::uint32 value);

  // optional bool store = 5;
  bool has_store() const;
  void clear_store();
  static const int kStoreFieldNumber = 5;
  bool store() const;
  void set_store(bool value);

  // optional uint32 service_id = 7;
  bool has_service_id() const;
  void clear_service_id();
  static const int kServiceIdFieldNumber = 7;
  ::google::protobuf::uint32 service_id() const;
  void set_service_id(::google::protobuf::uint32 value);

  // optional uint32 expire_time = 12;
  bool has_expire_time() const;
  void clear_expire_time();
  static const int kExpireTimeFieldNumber = 12;
  ::google::protobuf::uint32 expire_time() const;
  void set_expire_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.ChatReq)
 private:
  void set_has_body();
  void clear_has_body();
  void set_has_body_id();
  void clear_has_body_id();
  void set_has_more_flag();
  void clear_has_more_flag();
  void set_has_body_type();
  void clear_has_body_type();
  void set_has_store();
  void clear_has_store();
  void set_has_m_parameter();
  void clear_has_m_parameter();
  void set_has_service_id();
  void clear_has_service_id();
  void set_has_s_parameter();
  void clear_has_s_parameter();
  void set_has_expire_time();
  void clear_has_expire_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  ::google::protobuf::internal::ArenaStringPtr m_parameter_;
  ::google::protobuf::internal::ArenaStringPtr s_parameter_;
  ::google::protobuf::uint32 body_id_;
  ::google::protobuf::uint32 more_flag_;
  ::google::protobuf::uint32 body_type_;
  bool store_;
  ::google::protobuf::uint32 service_id_;
  ::google::protobuf::uint32 expire_time_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChatResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.ChatResp) */ {
 public:
  ChatResp();
  virtual ~ChatResp();

  ChatResp(const ChatResp& from);

  inline ChatResp& operator=(const ChatResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatResp& default_instance();

  static inline const ChatResp* internal_default_instance() {
    return reinterpret_cast<const ChatResp*>(
               &_ChatResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ChatResp* other);

  // implements Message ----------------------------------------------

  inline ChatResp* New() const PROTOBUF_FINAL { return New(NULL); }

  ChatResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChatResp& from);
  void MergeFrom(const ChatResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChatResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // optional uint32 body_id = 2;
  bool has_body_id() const;
  void clear_body_id();
  static const int kBodyIdFieldNumber = 2;
  ::google::protobuf::uint32 body_id() const;
  void set_body_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.ChatResp)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_body_id();
  void clear_has_body_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 body_id_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetInfoReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.GetInfoReq) */ {
 public:
  GetInfoReq();
  virtual ~GetInfoReq();

  GetInfoReq(const GetInfoReq& from);

  inline GetInfoReq& operator=(const GetInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetInfoReq& default_instance();

  static inline const GetInfoReq* internal_default_instance() {
    return reinterpret_cast<const GetInfoReq*>(
               &_GetInfoReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(GetInfoReq* other);

  // implements Message ----------------------------------------------

  inline GetInfoReq* New() const PROTOBUF_FINAL { return New(NULL); }

  GetInfoReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetInfoReq& from);
  void MergeFrom(const GetInfoReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetInfoReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string info_type = 1;
  bool has_info_type() const;
  void clear_info_type();
  static const int kInfoTypeFieldNumber = 1;
  const ::std::string& info_type() const;
  void set_info_type(const ::std::string& value);
  #if LANG_CXX11
  void set_info_type(::std::string&& value);
  #endif
  void set_info_type(const char* value);
  void set_info_type(const char* value, size_t size);
  ::std::string* mutable_info_type();
  ::std::string* release_info_type();
  void set_allocated_info_type(::std::string* info_type);

  // optional bytes s_parameter = 4;
  bool has_s_parameter() const;
  void clear_s_parameter();
  static const int kSParameterFieldNumber = 4;
  const ::std::string& s_parameter() const;
  void set_s_parameter(const ::std::string& value);
  #if LANG_CXX11
  void set_s_parameter(::std::string&& value);
  #endif
  void set_s_parameter(const char* value);
  void set_s_parameter(const void* value, size_t size);
  ::std::string* mutable_s_parameter();
  ::std::string* release_s_parameter();
  void set_allocated_s_parameter(::std::string* s_parameter);

  // required int64 get_info_id = 2;
  bool has_get_info_id() const;
  void clear_get_info_id();
  static const int kGetInfoIdFieldNumber = 2;
  ::google::protobuf::int64 get_info_id() const;
  void set_get_info_id(::google::protobuf::int64 value);

  // optional int32 get_info_offset = 3;
  bool has_get_info_offset() const;
  void clear_get_info_offset();
  static const int kGetInfoOffsetFieldNumber = 3;
  ::google::protobuf::int32 get_info_offset() const;
  void set_get_info_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.GetInfoReq)
 private:
  void set_has_info_type();
  void clear_has_info_type();
  void set_has_get_info_id();
  void clear_has_get_info_id();
  void set_has_get_info_offset();
  void clear_has_get_info_offset();
  void set_has_s_parameter();
  void clear_has_s_parameter();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr info_type_;
  ::google::protobuf::internal::ArenaStringPtr s_parameter_;
  ::google::protobuf::int64 get_info_id_;
  ::google::protobuf::int32 get_info_offset_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetInfoResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.GetInfoResp) */ {
 public:
  GetInfoResp();
  virtual ~GetInfoResp();

  GetInfoResp(const GetInfoResp& from);

  inline GetInfoResp& operator=(const GetInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetInfoResp& default_instance();

  static inline const GetInfoResp* internal_default_instance() {
    return reinterpret_cast<const GetInfoResp*>(
               &_GetInfoResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(GetInfoResp* other);

  // implements Message ----------------------------------------------

  inline GetInfoResp* New() const PROTOBUF_FINAL { return New(NULL); }

  GetInfoResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetInfoResp& from);
  void MergeFrom(const GetInfoResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetInfoResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qihoo.protocol.messages.Info infos = 2;
  int infos_size() const;
  void clear_infos();
  static const int kInfosFieldNumber = 2;
  const ::qihoo::protocol::messages::Info& infos(int index) const;
  ::qihoo::protocol::messages::Info* mutable_infos(int index);
  ::qihoo::protocol::messages::Info* add_infos();
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >*
      mutable_infos();
  const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >&
      infos() const;

  // required string info_type = 1;
  bool has_info_type() const;
  void clear_info_type();
  static const int kInfoTypeFieldNumber = 1;
  const ::std::string& info_type() const;
  void set_info_type(const ::std::string& value);
  #if LANG_CXX11
  void set_info_type(::std::string&& value);
  #endif
  void set_info_type(const char* value);
  void set_info_type(const char* value, size_t size);
  ::std::string* mutable_info_type();
  ::std::string* release_info_type();
  void set_allocated_info_type(::std::string* info_type);

  // optional bytes s_parameter = 4;
  bool has_s_parameter() const;
  void clear_s_parameter();
  static const int kSParameterFieldNumber = 4;
  const ::std::string& s_parameter() const;
  void set_s_parameter(const ::std::string& value);
  #if LANG_CXX11
  void set_s_parameter(::std::string&& value);
  #endif
  void set_s_parameter(const char* value);
  void set_s_parameter(const void* value, size_t size);
  ::std::string* mutable_s_parameter();
  ::std::string* release_s_parameter();
  void set_allocated_s_parameter(::std::string* s_parameter);

  // optional int64 last_info_id = 3;
  bool has_last_info_id() const;
  void clear_last_info_id();
  static const int kLastInfoIdFieldNumber = 3;
  ::google::protobuf::int64 last_info_id() const;
  void set_last_info_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.GetInfoResp)
 private:
  void set_has_info_type();
  void clear_has_info_type();
  void set_has_last_info_id();
  void clear_has_last_info_id();
  void set_has_s_parameter();
  void clear_has_s_parameter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info > infos_;
  ::google::protobuf::internal::ArenaStringPtr info_type_;
  ::google::protobuf::internal::ArenaStringPtr s_parameter_;
  ::google::protobuf::int64 last_info_id_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetMultiInfosReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.GetMultiInfosReq) */ {
 public:
  GetMultiInfosReq();
  virtual ~GetMultiInfosReq();

  GetMultiInfosReq(const GetMultiInfosReq& from);

  inline GetMultiInfosReq& operator=(const GetMultiInfosReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMultiInfosReq& default_instance();

  static inline const GetMultiInfosReq* internal_default_instance() {
    return reinterpret_cast<const GetMultiInfosReq*>(
               &_GetMultiInfosReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(GetMultiInfosReq* other);

  // implements Message ----------------------------------------------

  inline GetMultiInfosReq* New() const PROTOBUF_FINAL { return New(NULL); }

  GetMultiInfosReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetMultiInfosReq& from);
  void MergeFrom(const GetMultiInfosReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetMultiInfosReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 get_info_ids = 2;
  int get_info_ids_size() const;
  void clear_get_info_ids();
  static const int kGetInfoIdsFieldNumber = 2;
  ::google::protobuf::int64 get_info_ids(int index) const;
  void set_get_info_ids(int index, ::google::protobuf::int64 value);
  void add_get_info_ids(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      get_info_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_get_info_ids();

  // required string info_type = 1;
  bool has_info_type() const;
  void clear_info_type();
  static const int kInfoTypeFieldNumber = 1;
  const ::std::string& info_type() const;
  void set_info_type(const ::std::string& value);
  #if LANG_CXX11
  void set_info_type(::std::string&& value);
  #endif
  void set_info_type(const char* value);
  void set_info_type(const char* value, size_t size);
  ::std::string* mutable_info_type();
  ::std::string* release_info_type();
  void set_allocated_info_type(::std::string* info_type);

  // optional bytes s_parameter = 3;
  bool has_s_parameter() const;
  void clear_s_parameter();
  static const int kSParameterFieldNumber = 3;
  const ::std::string& s_parameter() const;
  void set_s_parameter(const ::std::string& value);
  #if LANG_CXX11
  void set_s_parameter(::std::string&& value);
  #endif
  void set_s_parameter(const char* value);
  void set_s_parameter(const void* value, size_t size);
  ::std::string* mutable_s_parameter();
  ::std::string* release_s_parameter();
  void set_allocated_s_parameter(::std::string* s_parameter);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.GetMultiInfosReq)
 private:
  void set_has_info_type();
  void clear_has_info_type();
  void set_has_s_parameter();
  void clear_has_s_parameter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > get_info_ids_;
  ::google::protobuf::internal::ArenaStringPtr info_type_;
  ::google::protobuf::internal::ArenaStringPtr s_parameter_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetMultiInfosResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.GetMultiInfosResp) */ {
 public:
  GetMultiInfosResp();
  virtual ~GetMultiInfosResp();

  GetMultiInfosResp(const GetMultiInfosResp& from);

  inline GetMultiInfosResp& operator=(const GetMultiInfosResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMultiInfosResp& default_instance();

  static inline const GetMultiInfosResp* internal_default_instance() {
    return reinterpret_cast<const GetMultiInfosResp*>(
               &_GetMultiInfosResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(GetMultiInfosResp* other);

  // implements Message ----------------------------------------------

  inline GetMultiInfosResp* New() const PROTOBUF_FINAL { return New(NULL); }

  GetMultiInfosResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetMultiInfosResp& from);
  void MergeFrom(const GetMultiInfosResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetMultiInfosResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qihoo.protocol.messages.Info infos = 2;
  int infos_size() const;
  void clear_infos();
  static const int kInfosFieldNumber = 2;
  const ::qihoo::protocol::messages::Info& infos(int index) const;
  ::qihoo::protocol::messages::Info* mutable_infos(int index);
  ::qihoo::protocol::messages::Info* add_infos();
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >*
      mutable_infos();
  const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >&
      infos() const;

  // required string info_type = 1;
  bool has_info_type() const;
  void clear_info_type();
  static const int kInfoTypeFieldNumber = 1;
  const ::std::string& info_type() const;
  void set_info_type(const ::std::string& value);
  #if LANG_CXX11
  void set_info_type(::std::string&& value);
  #endif
  void set_info_type(const char* value);
  void set_info_type(const char* value, size_t size);
  ::std::string* mutable_info_type();
  ::std::string* release_info_type();
  void set_allocated_info_type(::std::string* info_type);

  // optional bytes s_parameter = 4;
  bool has_s_parameter() const;
  void clear_s_parameter();
  static const int kSParameterFieldNumber = 4;
  const ::std::string& s_parameter() const;
  void set_s_parameter(const ::std::string& value);
  #if LANG_CXX11
  void set_s_parameter(::std::string&& value);
  #endif
  void set_s_parameter(const char* value);
  void set_s_parameter(const void* value, size_t size);
  ::std::string* mutable_s_parameter();
  ::std::string* release_s_parameter();
  void set_allocated_s_parameter(::std::string* s_parameter);

  // optional int64 last_info_id = 3;
  bool has_last_info_id() const;
  void clear_last_info_id();
  static const int kLastInfoIdFieldNumber = 3;
  ::google::protobuf::int64 last_info_id() const;
  void set_last_info_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.GetMultiInfosResp)
 private:
  void set_has_info_type();
  void clear_has_info_type();
  void set_has_last_info_id();
  void clear_has_last_info_id();
  void set_has_s_parameter();
  void clear_has_s_parameter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info > infos_;
  ::google::protobuf::internal::ArenaStringPtr info_type_;
  ::google::protobuf::internal::ArenaStringPtr s_parameter_;
  ::google::protobuf::int64 last_info_id_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogoutReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.LogoutReq) */ {
 public:
  LogoutReq();
  virtual ~LogoutReq();

  LogoutReq(const LogoutReq& from);

  inline LogoutReq& operator=(const LogoutReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutReq& default_instance();

  static inline const LogoutReq* internal_default_instance() {
    return reinterpret_cast<const LogoutReq*>(
               &_LogoutReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(LogoutReq* other);

  // implements Message ----------------------------------------------

  inline LogoutReq* New() const PROTOBUF_FINAL { return New(NULL); }

  LogoutReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogoutReq& from);
  void MergeFrom(const LogoutReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogoutReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string reason = 1;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 1;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.LogoutReq)
 private:
  void set_has_reason();
  void clear_has_reason();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogoutResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.LogoutResp) */ {
 public:
  LogoutResp();
  virtual ~LogoutResp();

  LogoutResp(const LogoutResp& from);

  inline LogoutResp& operator=(const LogoutResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutResp& default_instance();

  static inline const LogoutResp* internal_default_instance() {
    return reinterpret_cast<const LogoutResp*>(
               &_LogoutResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(LogoutResp* other);

  // implements Message ----------------------------------------------

  inline LogoutResp* New() const PROTOBUF_FINAL { return New(NULL); }

  LogoutResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogoutResp& from);
  void MergeFrom(const LogoutResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogoutResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.LogoutResp)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 result_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitLoginReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.InitLoginReq) */ {
 public:
  InitLoginReq();
  virtual ~InitLoginReq();

  InitLoginReq(const InitLoginReq& from);

  inline InitLoginReq& operator=(const InitLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitLoginReq& default_instance();

  static inline const InitLoginReq* internal_default_instance() {
    return reinterpret_cast<const InitLoginReq*>(
               &_InitLoginReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(InitLoginReq* other);

  // implements Message ----------------------------------------------

  inline InitLoginReq* New() const PROTOBUF_FINAL { return New(NULL); }

  InitLoginReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InitLoginReq& from);
  void MergeFrom(const InitLoginReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InitLoginReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_ram = 1;
  bool has_client_ram() const;
  void clear_client_ram();
  static const int kClientRamFieldNumber = 1;
  const ::std::string& client_ram() const;
  void set_client_ram(const ::std::string& value);
  #if LANG_CXX11
  void set_client_ram(::std::string&& value);
  #endif
  void set_client_ram(const char* value);
  void set_client_ram(const char* value, size_t size);
  ::std::string* mutable_client_ram();
  ::std::string* release_client_ram();
  void set_allocated_client_ram(::std::string* client_ram);

  // optional string sig = 2;
  bool has_sig() const;
  void clear_sig();
  static const int kSigFieldNumber = 2;
  const ::std::string& sig() const;
  void set_sig(const ::std::string& value);
  #if LANG_CXX11
  void set_sig(::std::string&& value);
  #endif
  void set_sig(const char* value);
  void set_sig(const char* value, size_t size);
  ::std::string* mutable_sig();
  ::std::string* release_sig();
  void set_allocated_sig(::std::string* sig);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.InitLoginReq)
 private:
  void set_has_client_ram();
  void clear_has_client_ram();
  void set_has_sig();
  void clear_has_sig();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr client_ram_;
  ::google::protobuf::internal::ArenaStringPtr sig_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitLoginResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.InitLoginResp) */ {
 public:
  InitLoginResp();
  virtual ~InitLoginResp();

  InitLoginResp(const InitLoginResp& from);

  inline InitLoginResp& operator=(const InitLoginResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitLoginResp& default_instance();

  static inline const InitLoginResp* internal_default_instance() {
    return reinterpret_cast<const InitLoginResp*>(
               &_InitLoginResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(InitLoginResp* other);

  // implements Message ----------------------------------------------

  inline InitLoginResp* New() const PROTOBUF_FINAL { return New(NULL); }

  InitLoginResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InitLoginResp& from);
  void MergeFrom(const InitLoginResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InitLoginResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_ram = 1;
  bool has_client_ram() const;
  void clear_client_ram();
  static const int kClientRamFieldNumber = 1;
  const ::std::string& client_ram() const;
  void set_client_ram(const ::std::string& value);
  #if LANG_CXX11
  void set_client_ram(::std::string&& value);
  #endif
  void set_client_ram(const char* value);
  void set_client_ram(const char* value, size_t size);
  ::std::string* mutable_client_ram();
  ::std::string* release_client_ram();
  void set_allocated_client_ram(::std::string* client_ram);

  // required string server_ram = 2;
  bool has_server_ram() const;
  void clear_server_ram();
  static const int kServerRamFieldNumber = 2;
  const ::std::string& server_ram() const;
  void set_server_ram(const ::std::string& value);
  #if LANG_CXX11
  void set_server_ram(::std::string&& value);
  #endif
  void set_server_ram(const char* value);
  void set_server_ram(const char* value, size_t size);
  ::std::string* mutable_server_ram();
  ::std::string* release_server_ram();
  void set_allocated_server_ram(::std::string* server_ram);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.InitLoginResp)
 private:
  void set_has_client_ram();
  void clear_has_client_ram();
  void set_has_server_ram();
  void clear_has_server_ram();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr client_ram_;
  ::google::protobuf::internal::ArenaStringPtr server_ram_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Service_Req : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.Service_Req) */ {
 public:
  Service_Req();
  virtual ~Service_Req();

  Service_Req(const Service_Req& from);

  inline Service_Req& operator=(const Service_Req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Service_Req& default_instance();

  static inline const Service_Req* internal_default_instance() {
    return reinterpret_cast<const Service_Req*>(
               &_Service_Req_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(Service_Req* other);

  // implements Message ----------------------------------------------

  inline Service_Req* New() const PROTOBUF_FINAL { return New(NULL); }

  Service_Req* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Service_Req& from);
  void MergeFrom(const Service_Req& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Service_Req* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes request = 2;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 2;
  const ::std::string& request() const;
  void set_request(const ::std::string& value);
  #if LANG_CXX11
  void set_request(::std::string&& value);
  #endif
  void set_request(const char* value);
  void set_request(const void* value, size_t size);
  ::std::string* mutable_request();
  ::std::string* release_request();
  void set_allocated_request(::std::string* request);

  // required uint32 service_id = 1;
  bool has_service_id() const;
  void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  ::google::protobuf::uint32 service_id() const;
  void set_service_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Service_Req)
 private:
  void set_has_service_id();
  void clear_has_service_id();
  void set_has_request();
  void clear_has_request();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr request_;
  ::google::protobuf::uint32 service_id_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Service_Resp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.Service_Resp) */ {
 public:
  Service_Resp();
  virtual ~Service_Resp();

  Service_Resp(const Service_Resp& from);

  inline Service_Resp& operator=(const Service_Resp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Service_Resp& default_instance();

  static inline const Service_Resp* internal_default_instance() {
    return reinterpret_cast<const Service_Resp*>(
               &_Service_Resp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(Service_Resp* other);

  // implements Message ----------------------------------------------

  inline Service_Resp* New() const PROTOBUF_FINAL { return New(NULL); }

  Service_Resp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Service_Resp& from);
  void MergeFrom(const Service_Resp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Service_Resp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes response = 2;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 2;
  const ::std::string& response() const;
  void set_response(const ::std::string& value);
  #if LANG_CXX11
  void set_response(::std::string&& value);
  #endif
  void set_response(const char* value);
  void set_response(const void* value, size_t size);
  ::std::string* mutable_response();
  ::std::string* release_response();
  void set_allocated_response(::std::string* response);

  // required uint32 service_id = 1;
  bool has_service_id() const;
  void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  ::google::protobuf::uint32 service_id() const;
  void set_service_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Service_Resp)
 private:
  void set_has_service_id();
  void clear_has_service_id();
  void set_has_response();
  void clear_has_response();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr response_;
  ::google::protobuf::uint32 service_id_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReqEQ1User : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.ReqEQ1User) */ {
 public:
  ReqEQ1User();
  virtual ~ReqEQ1User();

  ReqEQ1User(const ReqEQ1User& from);

  inline ReqEQ1User& operator=(const ReqEQ1User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqEQ1User& default_instance();

  static inline const ReqEQ1User* internal_default_instance() {
    return reinterpret_cast<const ReqEQ1User*>(
               &_ReqEQ1User_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(ReqEQ1User* other);

  // implements Message ----------------------------------------------

  inline ReqEQ1User* New() const PROTOBUF_FINAL { return New(NULL); }

  ReqEQ1User* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReqEQ1User& from);
  void MergeFrom(const ReqEQ1User& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReqEQ1User* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userid = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUseridFieldNumber = 1;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // required string user_type = 2;
  bool has_user_type() const;
  void clear_user_type();
  static const int kUserTypeFieldNumber = 2;
  const ::std::string& user_type() const;
  void set_user_type(const ::std::string& value);
  #if LANG_CXX11
  void set_user_type(::std::string&& value);
  #endif
  void set_user_type(const char* value);
  void set_user_type(const char* value, size_t size);
  ::std::string* mutable_user_type();
  ::std::string* release_user_type();
  void set_allocated_user_type(::std::string* user_type);

  // optional uint32 app_id = 3;
  bool has_app_id() const;
  void clear_app_id();
  static const int kAppIdFieldNumber = 3;
  ::google::protobuf::uint32 app_id() const;
  void set_app_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.ReqEQ1User)
 private:
  void set_has_userid();
  void clear_has_userid();
  void set_has_user_type();
  void clear_has_user_type();
  void set_has_app_id();
  void clear_has_app_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::internal::ArenaStringPtr user_type_;
  ::google::protobuf::uint32 app_id_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RespEQ1User : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.RespEQ1User) */ {
 public:
  RespEQ1User();
  virtual ~RespEQ1User();

  RespEQ1User(const RespEQ1User& from);

  inline RespEQ1User& operator=(const RespEQ1User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespEQ1User& default_instance();

  static inline const RespEQ1User* internal_default_instance() {
    return reinterpret_cast<const RespEQ1User*>(
               &_RespEQ1User_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(RespEQ1User* other);

  // implements Message ----------------------------------------------

  inline RespEQ1User* New() const PROTOBUF_FINAL { return New(NULL); }

  RespEQ1User* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RespEQ1User& from);
  void MergeFrom(const RespEQ1User& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RespEQ1User* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userid = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUseridFieldNumber = 1;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // required string user_type = 2;
  bool has_user_type() const;
  void clear_user_type();
  static const int kUserTypeFieldNumber = 2;
  const ::std::string& user_type() const;
  void set_user_type(const ::std::string& value);
  #if LANG_CXX11
  void set_user_type(::std::string&& value);
  #endif
  void set_user_type(const char* value);
  void set_user_type(const char* value, size_t size);
  ::std::string* mutable_user_type();
  ::std::string* release_user_type();
  void set_allocated_user_type(::std::string* user_type);

  // optional string jid = 4;
  bool has_jid() const;
  void clear_jid();
  static const int kJidFieldNumber = 4;
  const ::std::string& jid() const;
  void set_jid(const ::std::string& value);
  #if LANG_CXX11
  void set_jid(::std::string&& value);
  #endif
  void set_jid(const char* value);
  void set_jid(const char* value, size_t size);
  ::std::string* mutable_jid();
  ::std::string* release_jid();
  void set_allocated_jid(::std::string* jid);

  // optional string platform = 6;
  bool has_platform() const;
  void clear_platform();
  static const int kPlatformFieldNumber = 6;
  const ::std::string& platform() const;
  void set_platform(const ::std::string& value);
  #if LANG_CXX11
  void set_platform(::std::string&& value);
  #endif
  void set_platform(const char* value);
  void set_platform(const char* value, size_t size);
  ::std::string* mutable_platform();
  ::std::string* release_platform();
  void set_allocated_platform(::std::string* platform);

  // optional string mobile_type = 7;
  bool has_mobile_type() const;
  void clear_mobile_type();
  static const int kMobileTypeFieldNumber = 7;
  const ::std::string& mobile_type() const;
  void set_mobile_type(const ::std::string& value);
  #if LANG_CXX11
  void set_mobile_type(::std::string&& value);
  #endif
  void set_mobile_type(const char* value);
  void set_mobile_type(const char* value, size_t size);
  ::std::string* mutable_mobile_type();
  ::std::string* release_mobile_type();
  void set_allocated_mobile_type(::std::string* mobile_type);

  // required int32 status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // optional uint32 app_id = 5;
  bool has_app_id() const;
  void clear_app_id();
  static const int kAppIdFieldNumber = 5;
  ::google::protobuf::uint32 app_id() const;
  void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 client_ver = 8;
  bool has_client_ver() const;
  void clear_client_ver();
  static const int kClientVerFieldNumber = 8;
  ::google::protobuf::uint32 client_ver() const;
  void set_client_ver(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.RespEQ1User)
 private:
  void set_has_userid();
  void clear_has_userid();
  void set_has_user_type();
  void clear_has_user_type();
  void set_has_status();
  void clear_has_status();
  void set_has_jid();
  void clear_has_jid();
  void set_has_app_id();
  void clear_has_app_id();
  void set_has_platform();
  void clear_has_platform();
  void set_has_mobile_type();
  void clear_has_mobile_type();
  void set_has_client_ver();
  void clear_has_client_ver();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::internal::ArenaStringPtr user_type_;
  ::google::protobuf::internal::ArenaStringPtr jid_;
  ::google::protobuf::internal::ArenaStringPtr platform_;
  ::google::protobuf::internal::ArenaStringPtr mobile_type_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 client_ver_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ex1QueryUserStatusReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.Ex1QueryUserStatusReq) */ {
 public:
  Ex1QueryUserStatusReq();
  virtual ~Ex1QueryUserStatusReq();

  Ex1QueryUserStatusReq(const Ex1QueryUserStatusReq& from);

  inline Ex1QueryUserStatusReq& operator=(const Ex1QueryUserStatusReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ex1QueryUserStatusReq& default_instance();

  static inline const Ex1QueryUserStatusReq* internal_default_instance() {
    return reinterpret_cast<const Ex1QueryUserStatusReq*>(
               &_Ex1QueryUserStatusReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(Ex1QueryUserStatusReq* other);

  // implements Message ----------------------------------------------

  inline Ex1QueryUserStatusReq* New() const PROTOBUF_FINAL { return New(NULL); }

  Ex1QueryUserStatusReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ex1QueryUserStatusReq& from);
  void MergeFrom(const Ex1QueryUserStatusReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ex1QueryUserStatusReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qihoo.protocol.messages.ReqEQ1User user_list = 1;
  int user_list_size() const;
  void clear_user_list();
  static const int kUserListFieldNumber = 1;
  const ::qihoo::protocol::messages::ReqEQ1User& user_list(int index) const;
  ::qihoo::protocol::messages::ReqEQ1User* mutable_user_list(int index);
  ::qihoo::protocol::messages::ReqEQ1User* add_user_list();
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::ReqEQ1User >*
      mutable_user_list();
  const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::ReqEQ1User >&
      user_list() const;

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Ex1QueryUserStatusReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::ReqEQ1User > user_list_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ex1QueryUserStatusResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.Ex1QueryUserStatusResp) */ {
 public:
  Ex1QueryUserStatusResp();
  virtual ~Ex1QueryUserStatusResp();

  Ex1QueryUserStatusResp(const Ex1QueryUserStatusResp& from);

  inline Ex1QueryUserStatusResp& operator=(const Ex1QueryUserStatusResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ex1QueryUserStatusResp& default_instance();

  static inline const Ex1QueryUserStatusResp* internal_default_instance() {
    return reinterpret_cast<const Ex1QueryUserStatusResp*>(
               &_Ex1QueryUserStatusResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(Ex1QueryUserStatusResp* other);

  // implements Message ----------------------------------------------

  inline Ex1QueryUserStatusResp* New() const PROTOBUF_FINAL { return New(NULL); }

  Ex1QueryUserStatusResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ex1QueryUserStatusResp& from);
  void MergeFrom(const Ex1QueryUserStatusResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ex1QueryUserStatusResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qihoo.protocol.messages.RespEQ1User user_list = 1;
  int user_list_size() const;
  void clear_user_list();
  static const int kUserListFieldNumber = 1;
  const ::qihoo::protocol::messages::RespEQ1User& user_list(int index) const;
  ::qihoo::protocol::messages::RespEQ1User* mutable_user_list(int index);
  ::qihoo::protocol::messages::RespEQ1User* add_user_list();
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RespEQ1User >*
      mutable_user_list();
  const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RespEQ1User >&
      user_list() const;

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Ex1QueryUserStatusResp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RespEQ1User > user_list_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  inline Request* New() const PROTOBUF_FINAL { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .qihoo.protocol.messages.LoginReq login = 2;
  bool has_login() const;
  void clear_login();
  static const int kLoginFieldNumber = 2;
  const ::qihoo::protocol::messages::LoginReq& login() const;
  ::qihoo::protocol::messages::LoginReq* mutable_login();
  ::qihoo::protocol::messages::LoginReq* release_login();
  void set_allocated_login(::qihoo::protocol::messages::LoginReq* login);

  // optional .qihoo.protocol.messages.ChatReq chat = 3;
  bool has_chat() const;
  void clear_chat();
  static const int kChatFieldNumber = 3;
  const ::qihoo::protocol::messages::ChatReq& chat() const;
  ::qihoo::protocol::messages::ChatReq* mutable_chat();
  ::qihoo::protocol::messages::ChatReq* release_chat();
  void set_allocated_chat(::qihoo::protocol::messages::ChatReq* chat);

  // optional .qihoo.protocol.messages.GetInfoReq get_info = 5;
  bool has_get_info() const;
  void clear_get_info();
  static const int kGetInfoFieldNumber = 5;
  const ::qihoo::protocol::messages::GetInfoReq& get_info() const;
  ::qihoo::protocol::messages::GetInfoReq* mutable_get_info();
  ::qihoo::protocol::messages::GetInfoReq* release_get_info();
  void set_allocated_get_info(::qihoo::protocol::messages::GetInfoReq* get_info);

  // optional .qihoo.protocol.messages.LogoutReq logout = 6;
  bool has_logout() const;
  void clear_logout();
  static const int kLogoutFieldNumber = 6;
  const ::qihoo::protocol::messages::LogoutReq& logout() const;
  ::qihoo::protocol::messages::LogoutReq* mutable_logout();
  ::qihoo::protocol::messages::LogoutReq* release_logout();
  void set_allocated_logout(::qihoo::protocol::messages::LogoutReq* logout);

  // optional .qihoo.protocol.messages.InitLoginReq init_login_req = 9;
  bool has_init_login_req() const;
  void clear_init_login_req();
  static const int kInitLoginReqFieldNumber = 9;
  const ::qihoo::protocol::messages::InitLoginReq& init_login_req() const;
  ::qihoo::protocol::messages::InitLoginReq* mutable_init_login_req();
  ::qihoo::protocol::messages::InitLoginReq* release_init_login_req();
  void set_allocated_init_login_req(::qihoo::protocol::messages::InitLoginReq* init_login_req);

  // optional .qihoo.protocol.messages.Service_Req service_req = 11;
  bool has_service_req() const;
  void clear_service_req();
  static const int kServiceReqFieldNumber = 11;
  const ::qihoo::protocol::messages::Service_Req& service_req() const;
  ::qihoo::protocol::messages::Service_Req* mutable_service_req();
  ::qihoo::protocol::messages::Service_Req* release_service_req();
  void set_allocated_service_req(::qihoo::protocol::messages::Service_Req* service_req);

  // optional .qihoo.protocol.messages.Ex1QueryUserStatusReq e1_query_user = 12;
  bool has_e1_query_user() const;
  void clear_e1_query_user();
  static const int kE1QueryUserFieldNumber = 12;
  const ::qihoo::protocol::messages::Ex1QueryUserStatusReq& e1_query_user() const;
  ::qihoo::protocol::messages::Ex1QueryUserStatusReq* mutable_e1_query_user();
  ::qihoo::protocol::messages::Ex1QueryUserStatusReq* release_e1_query_user();
  void set_allocated_e1_query_user(::qihoo::protocol::messages::Ex1QueryUserStatusReq* e1_query_user);

  // optional .qihoo.protocol.messages.GetMultiInfosReq get_multi_infos = 100;
  bool has_get_multi_infos() const;
  void clear_get_multi_infos();
  static const int kGetMultiInfosFieldNumber = 100;
  const ::qihoo::protocol::messages::GetMultiInfosReq& get_multi_infos() const;
  ::qihoo::protocol::messages::GetMultiInfosReq* mutable_get_multi_infos();
  ::qihoo::protocol::messages::GetMultiInfosReq* release_get_multi_infos();
  void set_allocated_get_multi_infos(::qihoo::protocol::messages::GetMultiInfosReq* get_multi_infos);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Request)
 private:
  void set_has_login();
  void clear_has_login();
  void set_has_chat();
  void clear_has_chat();
  void set_has_get_info();
  void clear_has_get_info();
  void set_has_logout();
  void clear_has_logout();
  void set_has_init_login_req();
  void clear_has_init_login_req();
  void set_has_service_req();
  void clear_has_service_req();
  void set_has_e1_query_user();
  void clear_has_e1_query_user();
  void set_has_get_multi_infos();
  void clear_has_get_multi_infos();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::qihoo::protocol::messages::LoginReq* login_;
  ::qihoo::protocol::messages::ChatReq* chat_;
  ::qihoo::protocol::messages::GetInfoReq* get_info_;
  ::qihoo::protocol::messages::LogoutReq* logout_;
  ::qihoo::protocol::messages::InitLoginReq* init_login_req_;
  ::qihoo::protocol::messages::Service_Req* service_req_;
  ::qihoo::protocol::messages::Ex1QueryUserStatusReq* e1_query_user_;
  ::qihoo::protocol::messages::GetMultiInfosReq* get_multi_infos_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  inline Response* New() const PROTOBUF_FINAL { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .qihoo.protocol.messages.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::qihoo::protocol::messages::Error& error() const;
  ::qihoo::protocol::messages::Error* mutable_error();
  ::qihoo::protocol::messages::Error* release_error();
  void set_allocated_error(::qihoo::protocol::messages::Error* error);

  // optional .qihoo.protocol.messages.LoginResp login = 3;
  bool has_login() const;
  void clear_login();
  static const int kLoginFieldNumber = 3;
  const ::qihoo::protocol::messages::LoginResp& login() const;
  ::qihoo::protocol::messages::LoginResp* mutable_login();
  ::qihoo::protocol::messages::LoginResp* release_login();
  void set_allocated_login(::qihoo::protocol::messages::LoginResp* login);

  // optional .qihoo.protocol.messages.ChatResp chat = 4;
  bool has_chat() const;
  void clear_chat();
  static const int kChatFieldNumber = 4;
  const ::qihoo::protocol::messages::ChatResp& chat() const;
  ::qihoo::protocol::messages::ChatResp* mutable_chat();
  ::qihoo::protocol::messages::ChatResp* release_chat();
  void set_allocated_chat(::qihoo::protocol::messages::ChatResp* chat);

  // optional .qihoo.protocol.messages.GetInfoResp get_info = 6;
  bool has_get_info() const;
  void clear_get_info();
  static const int kGetInfoFieldNumber = 6;
  const ::qihoo::protocol::messages::GetInfoResp& get_info() const;
  ::qihoo::protocol::messages::GetInfoResp* mutable_get_info();
  ::qihoo::protocol::messages::GetInfoResp* release_get_info();
  void set_allocated_get_info(::qihoo::protocol::messages::GetInfoResp* get_info);

  // optional .qihoo.protocol.messages.LogoutResp logout = 7;
  bool has_logout() const;
  void clear_logout();
  static const int kLogoutFieldNumber = 7;
  const ::qihoo::protocol::messages::LogoutResp& logout() const;
  ::qihoo::protocol::messages::LogoutResp* mutable_logout();
  ::qihoo::protocol::messages::LogoutResp* release_logout();
  void set_allocated_logout(::qihoo::protocol::messages::LogoutResp* logout);

  // optional .qihoo.protocol.messages.InitLoginResp init_login_resp = 10;
  bool has_init_login_resp() const;
  void clear_init_login_resp();
  static const int kInitLoginRespFieldNumber = 10;
  const ::qihoo::protocol::messages::InitLoginResp& init_login_resp() const;
  ::qihoo::protocol::messages::InitLoginResp* mutable_init_login_resp();
  ::qihoo::protocol::messages::InitLoginResp* release_init_login_resp();
  void set_allocated_init_login_resp(::qihoo::protocol::messages::InitLoginResp* init_login_resp);

  // optional .qihoo.protocol.messages.Service_Resp service_resp = 12;
  bool has_service_resp() const;
  void clear_service_resp();
  static const int kServiceRespFieldNumber = 12;
  const ::qihoo::protocol::messages::Service_Resp& service_resp() const;
  ::qihoo::protocol::messages::Service_Resp* mutable_service_resp();
  ::qihoo::protocol::messages::Service_Resp* release_service_resp();
  void set_allocated_service_resp(::qihoo::protocol::messages::Service_Resp* service_resp);

  // optional .qihoo.protocol.messages.Ex1QueryUserStatusResp e1_query_user = 13;
  bool has_e1_query_user() const;
  void clear_e1_query_user();
  static const int kE1QueryUserFieldNumber = 13;
  const ::qihoo::protocol::messages::Ex1QueryUserStatusResp& e1_query_user() const;
  ::qihoo::protocol::messages::Ex1QueryUserStatusResp* mutable_e1_query_user();
  ::qihoo::protocol::messages::Ex1QueryUserStatusResp* release_e1_query_user();
  void set_allocated_e1_query_user(::qihoo::protocol::messages::Ex1QueryUserStatusResp* e1_query_user);

  // optional .qihoo.protocol.messages.GetMultiInfosResp get_multi_infos = 100;
  bool has_get_multi_infos() const;
  void clear_get_multi_infos();
  static const int kGetMultiInfosFieldNumber = 100;
  const ::qihoo::protocol::messages::GetMultiInfosResp& get_multi_infos() const;
  ::qihoo::protocol::messages::GetMultiInfosResp* mutable_get_multi_infos();
  ::qihoo::protocol::messages::GetMultiInfosResp* release_get_multi_infos();
  void set_allocated_get_multi_infos(::qihoo::protocol::messages::GetMultiInfosResp* get_multi_infos);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Response)
 private:
  void set_has_error();
  void clear_has_error();
  void set_has_login();
  void clear_has_login();
  void set_has_chat();
  void clear_has_chat();
  void set_has_get_info();
  void clear_has_get_info();
  void set_has_logout();
  void clear_has_logout();
  void set_has_init_login_resp();
  void clear_has_init_login_resp();
  void set_has_service_resp();
  void clear_has_service_resp();
  void set_has_e1_query_user();
  void clear_has_e1_query_user();
  void set_has_get_multi_infos();
  void clear_has_get_multi_infos();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::qihoo::protocol::messages::Error* error_;
  ::qihoo::protocol::messages::LoginResp* login_;
  ::qihoo::protocol::messages::ChatResp* chat_;
  ::qihoo::protocol::messages::GetInfoResp* get_info_;
  ::qihoo::protocol::messages::LogoutResp* logout_;
  ::qihoo::protocol::messages::InitLoginResp* init_login_resp_;
  ::qihoo::protocol::messages::Service_Resp* service_resp_;
  ::qihoo::protocol::messages::Ex1QueryUserStatusResp* e1_query_user_;
  ::qihoo::protocol::messages::GetMultiInfosResp* get_multi_infos_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewMessageNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.NewMessageNotify) */ {
 public:
  NewMessageNotify();
  virtual ~NewMessageNotify();

  NewMessageNotify(const NewMessageNotify& from);

  inline NewMessageNotify& operator=(const NewMessageNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewMessageNotify& default_instance();

  static inline const NewMessageNotify* internal_default_instance() {
    return reinterpret_cast<const NewMessageNotify*>(
               &_NewMessageNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(NewMessageNotify* other);

  // implements Message ----------------------------------------------

  inline NewMessageNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  NewMessageNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewMessageNotify& from);
  void MergeFrom(const NewMessageNotify& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewMessageNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string info_type = 1;
  bool has_info_type() const;
  void clear_info_type();
  static const int kInfoTypeFieldNumber = 1;
  const ::std::string& info_type() const;
  void set_info_type(const ::std::string& value);
  #if LANG_CXX11
  void set_info_type(::std::string&& value);
  #endif
  void set_info_type(const char* value);
  void set_info_type(const char* value, size_t size);
  ::std::string* mutable_info_type();
  ::std::string* release_info_type();
  void set_allocated_info_type(::std::string* info_type);

  // optional bytes info_content = 2;
  bool has_info_content() const;
  void clear_info_content();
  static const int kInfoContentFieldNumber = 2;
  const ::std::string& info_content() const;
  void set_info_content(const ::std::string& value);
  #if LANG_CXX11
  void set_info_content(::std::string&& value);
  #endif
  void set_info_content(const char* value);
  void set_info_content(const void* value, size_t size);
  ::std::string* mutable_info_content();
  ::std::string* release_info_content();
  void set_allocated_info_content(::std::string* info_content);

  // optional int64 info_id = 3;
  bool has_info_id() const;
  void clear_info_id();
  static const int kInfoIdFieldNumber = 3;
  ::google::protobuf::int64 info_id() const;
  void set_info_id(::google::protobuf::int64 value);

  // optional uint32 query_after_seconds = 4;
  bool has_query_after_seconds() const;
  void clear_query_after_seconds();
  static const int kQueryAfterSecondsFieldNumber = 4;
  ::google::protobuf::uint32 query_after_seconds() const;
  void set_query_after_seconds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.NewMessageNotify)
 private:
  void set_has_info_type();
  void clear_has_info_type();
  void set_has_info_content();
  void clear_has_info_content();
  void set_has_info_id();
  void clear_has_info_id();
  void set_has_query_after_seconds();
  void clear_has_query_after_seconds();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr info_type_;
  ::google::protobuf::internal::ArenaStringPtr info_content_;
  ::google::protobuf::int64 info_id_;
  ::google::protobuf::uint32 query_after_seconds_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReLoginNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.ReLoginNotify) */ {
 public:
  ReLoginNotify();
  virtual ~ReLoginNotify();

  ReLoginNotify(const ReLoginNotify& from);

  inline ReLoginNotify& operator=(const ReLoginNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReLoginNotify& default_instance();

  static inline const ReLoginNotify* internal_default_instance() {
    return reinterpret_cast<const ReLoginNotify*>(
               &_ReLoginNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(ReLoginNotify* other);

  // implements Message ----------------------------------------------

  inline ReLoginNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  ReLoginNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReLoginNotify& from);
  void MergeFrom(const ReLoginNotify& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReLoginNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string new_ip = 1;
  bool has_new_ip() const;
  void clear_new_ip();
  static const int kNewIpFieldNumber = 1;
  const ::std::string& new_ip() const;
  void set_new_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_new_ip(::std::string&& value);
  #endif
  void set_new_ip(const char* value);
  void set_new_ip(const char* value, size_t size);
  ::std::string* mutable_new_ip();
  ::std::string* release_new_ip();
  void set_allocated_new_ip(::std::string* new_ip);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.ReLoginNotify)
 private:
  void set_has_new_ip();
  void clear_has_new_ip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr new_ip_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReConnectNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.ReConnectNotify) */ {
 public:
  ReConnectNotify();
  virtual ~ReConnectNotify();

  ReConnectNotify(const ReConnectNotify& from);

  inline ReConnectNotify& operator=(const ReConnectNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReConnectNotify& default_instance();

  static inline const ReConnectNotify* internal_default_instance() {
    return reinterpret_cast<const ReConnectNotify*>(
               &_ReConnectNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(ReConnectNotify* other);

  // implements Message ----------------------------------------------

  inline ReConnectNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  ReConnectNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReConnectNotify& from);
  void MergeFrom(const ReConnectNotify& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReConnectNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string more_ips = 3;
  int more_ips_size() const;
  void clear_more_ips();
  static const int kMoreIpsFieldNumber = 3;
  const ::std::string& more_ips(int index) const;
  ::std::string* mutable_more_ips(int index);
  void set_more_ips(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_more_ips(int index, ::std::string&& value);
  #endif
  void set_more_ips(int index, const char* value);
  void set_more_ips(int index, const char* value, size_t size);
  ::std::string* add_more_ips();
  void add_more_ips(const ::std::string& value);
  #if LANG_CXX11
  void add_more_ips(::std::string&& value);
  #endif
  void add_more_ips(const char* value);
  void add_more_ips(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& more_ips() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_more_ips();

  // optional string ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional uint32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.ReConnectNotify)
 private:
  void set_has_ip();
  void clear_has_ip();
  void set_has_port();
  void clear_has_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> more_ips_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::uint32 port_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Notify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.Notify) */ {
 public:
  Notify();
  virtual ~Notify();

  Notify(const Notify& from);

  inline Notify& operator=(const Notify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Notify& default_instance();

  static inline const Notify* internal_default_instance() {
    return reinterpret_cast<const Notify*>(
               &_Notify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(Notify* other);

  // implements Message ----------------------------------------------

  inline Notify* New() const PROTOBUF_FINAL { return New(NULL); }

  Notify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Notify& from);
  void MergeFrom(const Notify& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Notify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .qihoo.protocol.messages.NewMessageNotify newinfo_ntf = 1;
  bool has_newinfo_ntf() const;
  void clear_newinfo_ntf();
  static const int kNewinfoNtfFieldNumber = 1;
  const ::qihoo::protocol::messages::NewMessageNotify& newinfo_ntf() const;
  ::qihoo::protocol::messages::NewMessageNotify* mutable_newinfo_ntf();
  ::qihoo::protocol::messages::NewMessageNotify* release_newinfo_ntf();
  void set_allocated_newinfo_ntf(::qihoo::protocol::messages::NewMessageNotify* newinfo_ntf);

  // optional .qihoo.protocol.messages.ReLoginNotify relogin_ntf = 2;
  bool has_relogin_ntf() const;
  void clear_relogin_ntf();
  static const int kReloginNtfFieldNumber = 2;
  const ::qihoo::protocol::messages::ReLoginNotify& relogin_ntf() const;
  ::qihoo::protocol::messages::ReLoginNotify* mutable_relogin_ntf();
  ::qihoo::protocol::messages::ReLoginNotify* release_relogin_ntf();
  void set_allocated_relogin_ntf(::qihoo::protocol::messages::ReLoginNotify* relogin_ntf);

  // optional .qihoo.protocol.messages.ReConnectNotify reconnect_ntf = 3;
  bool has_reconnect_ntf() const;
  void clear_reconnect_ntf();
  static const int kReconnectNtfFieldNumber = 3;
  const ::qihoo::protocol::messages::ReConnectNotify& reconnect_ntf() const;
  ::qihoo::protocol::messages::ReConnectNotify* mutable_reconnect_ntf();
  ::qihoo::protocol::messages::ReConnectNotify* release_reconnect_ntf();
  void set_allocated_reconnect_ntf(::qihoo::protocol::messages::ReConnectNotify* reconnect_ntf);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Notify)
 private:
  void set_has_newinfo_ntf();
  void clear_has_newinfo_ntf();
  void set_has_relogin_ntf();
  void clear_has_relogin_ntf();
  void set_has_reconnect_ntf();
  void clear_has_reconnect_ntf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::qihoo::protocol::messages::NewMessageNotify* newinfo_ntf_;
  ::qihoo::protocol::messages::ReLoginNotify* relogin_ntf_;
  ::qihoo::protocol::messages::ReConnectNotify* reconnect_ntf_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.Ack) */ {
 public:
  Ack();
  virtual ~Ack();

  Ack(const Ack& from);

  inline Ack& operator=(const Ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ack& default_instance();

  static inline const Ack* internal_default_instance() {
    return reinterpret_cast<const Ack*>(
               &_Ack_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(Ack* other);

  // implements Message ----------------------------------------------

  inline Ack* New() const PROTOBUF_FINAL { return New(NULL); }

  Ack* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ack& from);
  void MergeFrom(const Ack& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Ack)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 result_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RouteInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.RouteInfo) */ {
 public:
  RouteInfo();
  virtual ~RouteInfo();

  RouteInfo(const RouteInfo& from);

  inline RouteInfo& operator=(const RouteInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteInfo& default_instance();

  static inline const RouteInfo* internal_default_instance() {
    return reinterpret_cast<const RouteInfo*>(
               &_RouteInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(RouteInfo* other);

  // implements Message ----------------------------------------------

  inline RouteInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteInfo& from);
  void MergeFrom(const RouteInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes username = 1;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const void* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // required string msg_exchanger = 2;
  bool has_msg_exchanger() const;
  void clear_msg_exchanger();
  static const int kMsgExchangerFieldNumber = 2;
  const ::std::string& msg_exchanger() const;
  void set_msg_exchanger(const ::std::string& value);
  #if LANG_CXX11
  void set_msg_exchanger(::std::string&& value);
  #endif
  void set_msg_exchanger(const char* value);
  void set_msg_exchanger(const char* value, size_t size);
  ::std::string* mutable_msg_exchanger();
  ::std::string* release_msg_exchanger();
  void set_allocated_msg_exchanger(::std::string* msg_exchanger);

  // required string msg_router = 3;
  bool has_msg_router() const;
  void clear_msg_router();
  static const int kMsgRouterFieldNumber = 3;
  const ::std::string& msg_router() const;
  void set_msg_router(const ::std::string& value);
  #if LANG_CXX11
  void set_msg_router(::std::string&& value);
  #endif
  void set_msg_router(const char* value);
  void set_msg_router(const char* value, size_t size);
  ::std::string* mutable_msg_router();
  ::std::string* release_msg_router();
  void set_allocated_msg_router(::std::string* msg_router);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.RouteInfo)
 private:
  void set_has_username();
  void clear_has_username();
  void set_has_msg_exchanger();
  void clear_has_msg_exchanger();
  void set_has_msg_router();
  void clear_has_msg_router();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr msg_exchanger_;
  ::google::protobuf::internal::ArenaStringPtr msg_router_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Proxy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.Proxy) */ {
 public:
  Proxy();
  virtual ~Proxy();

  Proxy(const Proxy& from);

  inline Proxy& operator=(const Proxy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proxy& default_instance();

  static inline const Proxy* internal_default_instance() {
    return reinterpret_cast<const Proxy*>(
               &_Proxy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(Proxy* other);

  // implements Message ----------------------------------------------

  inline Proxy* New() const PROTOBUF_FINAL { return New(NULL); }

  Proxy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Proxy& from);
  void MergeFrom(const Proxy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Proxy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qihoo.protocol.messages.RouteInfo receiver = 2;
  int receiver_size() const;
  void clear_receiver();
  static const int kReceiverFieldNumber = 2;
  const ::qihoo::protocol::messages::RouteInfo& receiver(int index) const;
  ::qihoo::protocol::messages::RouteInfo* mutable_receiver(int index);
  ::qihoo::protocol::messages::RouteInfo* add_receiver();
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RouteInfo >*
      mutable_receiver();
  const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RouteInfo >&
      receiver() const;

  // required string sender = 1;
  bool has_sender() const;
  void clear_sender();
  static const int kSenderFieldNumber = 1;
  const ::std::string& sender() const;
  void set_sender(const ::std::string& value);
  #if LANG_CXX11
  void set_sender(::std::string&& value);
  #endif
  void set_sender(const char* value);
  void set_sender(const char* value, size_t size);
  ::std::string* mutable_sender();
  ::std::string* release_sender();
  void set_allocated_sender(::std::string* sender);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Proxy)
 private:
  void set_has_sender();
  void clear_has_sender();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RouteInfo > receiver_;
  ::google::protobuf::internal::ArenaStringPtr sender_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:qihoo.protocol.messages.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  inline Message* New() const PROTOBUF_FINAL { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sender = 3;
  bool has_sender() const;
  void clear_sender();
  static const int kSenderFieldNumber = 3;
  const ::std::string& sender() const;
  void set_sender(const ::std::string& value);
  #if LANG_CXX11
  void set_sender(::std::string&& value);
  #endif
  void set_sender(const char* value);
  void set_sender(const char* value, size_t size);
  ::std::string* mutable_sender();
  ::std::string* release_sender();
  void set_allocated_sender(::std::string* sender);

  // optional string receiver = 4;
  bool has_receiver() const;
  void clear_receiver();
  static const int kReceiverFieldNumber = 4;
  const ::std::string& receiver() const;
  void set_receiver(const ::std::string& value);
  #if LANG_CXX11
  void set_receiver(::std::string&& value);
  #endif
  void set_receiver(const char* value);
  void set_receiver(const char* value, size_t size);
  ::std::string* mutable_receiver();
  ::std::string* release_receiver();
  void set_allocated_receiver(::std::string* receiver);

  // optional string receiver_type = 5;
  bool has_receiver_type() const;
  void clear_receiver_type();
  static const int kReceiverTypeFieldNumber = 5;
  const ::std::string& receiver_type() const;
  void set_receiver_type(const ::std::string& value);
  #if LANG_CXX11
  void set_receiver_type(::std::string&& value);
  #endif
  void set_receiver_type(const char* value);
  void set_receiver_type(const char* value, size_t size);
  ::std::string* mutable_receiver_type();
  ::std::string* release_receiver_type();
  void set_allocated_receiver_type(::std::string* receiver_type);

  // optional string sender_type = 12;
  bool has_sender_type() const;
  void clear_sender_type();
  static const int kSenderTypeFieldNumber = 12;
  const ::std::string& sender_type() const;
  void set_sender_type(const ::std::string& value);
  #if LANG_CXX11
  void set_sender_type(::std::string&& value);
  #endif
  void set_sender_type(const char* value);
  void set_sender_type(const char* value, size_t size);
  ::std::string* mutable_sender_type();
  ::std::string* release_sender_type();
  void set_allocated_sender_type(::std::string* sender_type);

  // optional string sender_jid = 13;
  bool has_sender_jid() const;
  void clear_sender_jid();
  static const int kSenderJidFieldNumber = 13;
  const ::std::string& sender_jid() const;
  void set_sender_jid(const ::std::string& value);
  #if LANG_CXX11
  void set_sender_jid(::std::string&& value);
  #endif
  void set_sender_jid(const char* value);
  void set_sender_jid(const char* value, size_t size);
  ::std::string* mutable_sender_jid();
  ::std::string* release_sender_jid();
  void set_allocated_sender_jid(::std::string* sender_jid);

  // optional .qihoo.protocol.messages.Request req = 6;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 6;
  const ::qihoo::protocol::messages::Request& req() const;
  ::qihoo::protocol::messages::Request* mutable_req();
  ::qihoo::protocol::messages::Request* release_req();
  void set_allocated_req(::qihoo::protocol::messages::Request* req);

  // optional .qihoo.protocol.messages.Response resp = 7;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 7;
  const ::qihoo::protocol::messages::Response& resp() const;
  ::qihoo::protocol::messages::Response* mutable_resp();
  ::qihoo::protocol::messages::Response* release_resp();
  void set_allocated_resp(::qihoo::protocol::messages::Response* resp);

  // optional .qihoo.protocol.messages.Notify notify = 8;
  bool has_notify() const;
  void clear_notify();
  static const int kNotifyFieldNumber = 8;
  const ::qihoo::protocol::messages::Notify& notify() const;
  ::qihoo::protocol::messages::Notify* mutable_notify();
  ::qihoo::protocol::messages::Notify* release_notify();
  void set_allocated_notify(::qihoo::protocol::messages::Notify* notify);

  // optional .qihoo.protocol.messages.Ack ack = 9;
  bool has_ack() const;
  void clear_ack();
  static const int kAckFieldNumber = 9;
  const ::qihoo::protocol::messages::Ack& ack() const;
  ::qihoo::protocol::messages::Ack* mutable_ack();
  ::qihoo::protocol::messages::Ack* release_ack();
  void set_allocated_ack(::qihoo::protocol::messages::Ack* ack);

  // optional .qihoo.protocol.messages.Proxy proxy_mesg = 10;
  bool has_proxy_mesg() const;
  void clear_proxy_mesg();
  static const int kProxyMesgFieldNumber = 10;
  const ::qihoo::protocol::messages::Proxy& proxy_mesg() const;
  ::qihoo::protocol::messages::Proxy* mutable_proxy_mesg();
  ::qihoo::protocol::messages::Proxy* release_proxy_mesg();
  void set_allocated_proxy_mesg(::qihoo::protocol::messages::Proxy* proxy_mesg);

  // required uint64 sn = 2;
  bool has_sn() const;
  void clear_sn();
  static const int kSnFieldNumber = 2;
  ::google::protobuf::uint64 sn() const;
  void set_sn(::google::protobuf::uint64 value);

  // optional uint64 client_data = 11;
  bool has_client_data() const;
  void clear_client_data();
  static const int kClientDataFieldNumber = 11;
  ::google::protobuf::uint64 client_data() const;
  void set_client_data(::google::protobuf::uint64 value);

  // required uint32 msgid = 1;
  bool has_msgid() const;
  void clear_msgid();
  static const int kMsgidFieldNumber = 1;
  ::google::protobuf::uint32 msgid() const;
  void set_msgid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Message)
 private:
  void set_has_msgid();
  void clear_has_msgid();
  void set_has_sn();
  void clear_has_sn();
  void set_has_sender();
  void clear_has_sender();
  void set_has_receiver();
  void clear_has_receiver();
  void set_has_receiver_type();
  void clear_has_receiver_type();
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();
  void set_has_notify();
  void clear_has_notify();
  void set_has_ack();
  void clear_has_ack();
  void set_has_proxy_mesg();
  void clear_has_proxy_mesg();
  void set_has_client_data();
  void clear_has_client_data();
  void set_has_sender_type();
  void clear_has_sender_type();
  void set_has_sender_jid();
  void clear_has_sender_jid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sender_;
  ::google::protobuf::internal::ArenaStringPtr receiver_;
  ::google::protobuf::internal::ArenaStringPtr receiver_type_;
  ::google::protobuf::internal::ArenaStringPtr sender_type_;
  ::google::protobuf::internal::ArenaStringPtr sender_jid_;
  ::qihoo::protocol::messages::Request* req_;
  ::qihoo::protocol::messages::Response* resp_;
  ::qihoo::protocol::messages::Notify* notify_;
  ::qihoo::protocol::messages::Ack* ack_;
  ::qihoo::protocol::messages::Proxy* proxy_mesg_;
  ::google::protobuf::uint64 sn_;
  ::google::protobuf::uint64 client_data_;
  ::google::protobuf::uint32 msgid_;
  friend struct protobuf_CommunicationData_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Pair

// required bytes key = 1;
inline bool Pair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Pair::key() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Pair.key)
  return key_.GetNoArena();
}
inline void Pair::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Pair.key)
}
#if LANG_CXX11
inline void Pair::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.Pair.key)
}
#endif
inline void Pair::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Pair.key)
}
inline void Pair::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Pair.key)
}
inline ::std::string* Pair::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Pair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Pair::release_key() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Pair.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Pair::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Pair.key)
}

// optional bytes value = 2;
inline bool Pair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pair::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Pair::value() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Pair.value)
  return value_.GetNoArena();
}
inline void Pair::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Pair.value)
}
#if LANG_CXX11
inline void Pair::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.Pair.value)
}
#endif
inline void Pair::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Pair.value)
}
inline void Pair::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Pair.value)
}
inline ::std::string* Pair::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Pair.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Pair::release_value() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Pair.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Pair::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Pair.value)
}

// -------------------------------------------------------------------

// Error

// required uint32 id = 1;
inline bool Error::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Error::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Error::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Error::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Error::id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Error.id)
  return id_;
}
inline void Error::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Error.id)
}

// optional bytes description = 2;
inline bool Error::has_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Error::set_has_description() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Error::clear_has_description() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Error::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& Error::description() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Error.description)
  return description_.GetNoArena();
}
inline void Error::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Error.description)
}
#if LANG_CXX11
inline void Error::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.Error.description)
}
#endif
inline void Error::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Error.description)
}
inline void Error::set_description(const void* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Error.description)
}
inline ::std::string* Error::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Error.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_description() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Error.description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Error.description)
}

// -------------------------------------------------------------------

// User

// required string userid = 1;
inline bool User::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_userid();
}
inline const ::std::string& User::userid() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.User.userid)
  return userid_.GetNoArena();
}
inline void User::set_userid(const ::std::string& value) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.User.userid)
}
#if LANG_CXX11
inline void User::set_userid(::std::string&& value) {
  set_has_userid();
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.User.userid)
}
#endif
inline void User::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.User.userid)
}
inline void User::set_userid(const char* value, size_t size) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.User.userid)
}
inline ::std::string* User::mutable_userid() {
  set_has_userid();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.User.userid)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_userid() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.User.userid)
  clear_has_userid();
  return userid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.User.userid)
}

// repeated .qihoo.protocol.messages.Pair property_pairs = 2;
inline int User::property_pairs_size() const {
  return property_pairs_.size();
}
inline void User::clear_property_pairs() {
  property_pairs_.Clear();
}
inline const ::qihoo::protocol::messages::Pair& User::property_pairs(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.User.property_pairs)
  return property_pairs_.Get(index);
}
inline ::qihoo::protocol::messages::Pair* User::mutable_property_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.User.property_pairs)
  return property_pairs_.Mutable(index);
}
inline ::qihoo::protocol::messages::Pair* User::add_property_pairs() {
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.User.property_pairs)
  return property_pairs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >*
User::mutable_property_pairs() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.User.property_pairs)
  return &property_pairs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >&
User::property_pairs() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.User.property_pairs)
  return property_pairs_;
}

// -------------------------------------------------------------------

// Info

// repeated .qihoo.protocol.messages.Pair property_pairs = 1;
inline int Info::property_pairs_size() const {
  return property_pairs_.size();
}
inline void Info::clear_property_pairs() {
  property_pairs_.Clear();
}
inline const ::qihoo::protocol::messages::Pair& Info::property_pairs(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Info.property_pairs)
  return property_pairs_.Get(index);
}
inline ::qihoo::protocol::messages::Pair* Info::mutable_property_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Info.property_pairs)
  return property_pairs_.Mutable(index);
}
inline ::qihoo::protocol::messages::Pair* Info::add_property_pairs() {
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.Info.property_pairs)
  return property_pairs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >*
Info::mutable_property_pairs() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.Info.property_pairs)
  return &property_pairs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >&
Info::property_pairs() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.Info.property_pairs)
  return property_pairs_;
}

// -------------------------------------------------------------------

// LoginReq

// required string mobile_type = 1;
inline bool LoginReq::has_mobile_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReq::set_has_mobile_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReq::clear_has_mobile_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReq::clear_mobile_type() {
  mobile_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mobile_type();
}
inline const ::std::string& LoginReq::mobile_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.mobile_type)
  return mobile_type_.GetNoArena();
}
inline void LoginReq::set_mobile_type(const ::std::string& value) {
  set_has_mobile_type();
  mobile_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.mobile_type)
}
#if LANG_CXX11
inline void LoginReq::set_mobile_type(::std::string&& value) {
  set_has_mobile_type();
  mobile_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.LoginReq.mobile_type)
}
#endif
inline void LoginReq::set_mobile_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mobile_type();
  mobile_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginReq.mobile_type)
}
inline void LoginReq::set_mobile_type(const char* value, size_t size) {
  set_has_mobile_type();
  mobile_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginReq.mobile_type)
}
inline ::std::string* LoginReq::mutable_mobile_type() {
  set_has_mobile_type();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginReq.mobile_type)
  return mobile_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReq::release_mobile_type() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.LoginReq.mobile_type)
  clear_has_mobile_type();
  return mobile_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReq::set_allocated_mobile_type(::std::string* mobile_type) {
  if (mobile_type != NULL) {
    set_has_mobile_type();
  } else {
    clear_has_mobile_type();
  }
  mobile_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mobile_type);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginReq.mobile_type)
}

// required uint32 net_type = 2;
inline bool LoginReq::has_net_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginReq::set_has_net_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginReq::clear_has_net_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginReq::clear_net_type() {
  net_type_ = 0u;
  clear_has_net_type();
}
inline ::google::protobuf::uint32 LoginReq::net_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.net_type)
  return net_type_;
}
inline void LoginReq::set_net_type(::google::protobuf::uint32 value) {
  set_has_net_type();
  net_type_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.net_type)
}

// required string server_ram = 3;
inline bool LoginReq::has_server_ram() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReq::set_has_server_ram() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReq::clear_has_server_ram() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReq::clear_server_ram() {
  server_ram_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_server_ram();
}
inline const ::std::string& LoginReq::server_ram() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.server_ram)
  return server_ram_.GetNoArena();
}
inline void LoginReq::set_server_ram(const ::std::string& value) {
  set_has_server_ram();
  server_ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.server_ram)
}
#if LANG_CXX11
inline void LoginReq::set_server_ram(::std::string&& value) {
  set_has_server_ram();
  server_ram_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.LoginReq.server_ram)
}
#endif
inline void LoginReq::set_server_ram(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_server_ram();
  server_ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginReq.server_ram)
}
inline void LoginReq::set_server_ram(const char* value, size_t size) {
  set_has_server_ram();
  server_ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginReq.server_ram)
}
inline ::std::string* LoginReq::mutable_server_ram() {
  set_has_server_ram();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginReq.server_ram)
  return server_ram_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReq::release_server_ram() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.LoginReq.server_ram)
  clear_has_server_ram();
  return server_ram_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReq::set_allocated_server_ram(::std::string* server_ram) {
  if (server_ram != NULL) {
    set_has_server_ram();
  } else {
    clear_has_server_ram();
  }
  server_ram_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_ram);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginReq.server_ram)
}

// optional bytes secret_ram = 4;
inline bool LoginReq::has_secret_ram() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginReq::set_has_secret_ram() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginReq::clear_has_secret_ram() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginReq::clear_secret_ram() {
  secret_ram_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_secret_ram();
}
inline const ::std::string& LoginReq::secret_ram() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.secret_ram)
  return secret_ram_.GetNoArena();
}
inline void LoginReq::set_secret_ram(const ::std::string& value) {
  set_has_secret_ram();
  secret_ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.secret_ram)
}
#if LANG_CXX11
inline void LoginReq::set_secret_ram(::std::string&& value) {
  set_has_secret_ram();
  secret_ram_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.LoginReq.secret_ram)
}
#endif
inline void LoginReq::set_secret_ram(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_secret_ram();
  secret_ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginReq.secret_ram)
}
inline void LoginReq::set_secret_ram(const void* value, size_t size) {
  set_has_secret_ram();
  secret_ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginReq.secret_ram)
}
inline ::std::string* LoginReq::mutable_secret_ram() {
  set_has_secret_ram();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginReq.secret_ram)
  return secret_ram_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReq::release_secret_ram() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.LoginReq.secret_ram)
  clear_has_secret_ram();
  return secret_ram_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReq::set_allocated_secret_ram(::std::string* secret_ram) {
  if (secret_ram != NULL) {
    set_has_secret_ram();
  } else {
    clear_has_secret_ram();
  }
  secret_ram_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret_ram);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginReq.secret_ram)
}

// optional uint32 app_id = 5 [default = 2000];
inline bool LoginReq::has_app_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginReq::set_has_app_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginReq::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginReq::clear_app_id() {
  app_id_ = 2000u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 LoginReq::app_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.app_id)
  return app_id_;
}
inline void LoginReq::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.app_id)
}

// optional uint32 heart_feq = 6 [default = 300];
inline bool LoginReq::has_heart_feq() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginReq::set_has_heart_feq() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoginReq::clear_has_heart_feq() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoginReq::clear_heart_feq() {
  heart_feq_ = 300u;
  clear_has_heart_feq();
}
inline ::google::protobuf::uint32 LoginReq::heart_feq() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.heart_feq)
  return heart_feq_;
}
inline void LoginReq::set_heart_feq(::google::protobuf::uint32 value) {
  set_has_heart_feq();
  heart_feq_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.heart_feq)
}

// optional string deviceid = 7;
inline bool LoginReq::has_deviceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginReq::set_has_deviceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginReq::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginReq::clear_deviceid() {
  deviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_deviceid();
}
inline const ::std::string& LoginReq::deviceid() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.deviceid)
  return deviceid_.GetNoArena();
}
inline void LoginReq::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.deviceid)
}
#if LANG_CXX11
inline void LoginReq::set_deviceid(::std::string&& value) {
  set_has_deviceid();
  deviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.LoginReq.deviceid)
}
#endif
inline void LoginReq::set_deviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_deviceid();
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginReq.deviceid)
}
inline void LoginReq::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginReq.deviceid)
}
inline ::std::string* LoginReq::mutable_deviceid() {
  set_has_deviceid();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginReq.deviceid)
  return deviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReq::release_deviceid() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.LoginReq.deviceid)
  clear_has_deviceid();
  return deviceid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReq::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid != NULL) {
    set_has_deviceid();
  } else {
    clear_has_deviceid();
  }
  deviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deviceid);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginReq.deviceid)
}

// optional string platform = 8;
inline bool LoginReq::has_platform() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginReq::set_has_platform() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginReq::clear_has_platform() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginReq::clear_platform() {
  platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_platform();
}
inline const ::std::string& LoginReq::platform() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.platform)
  return platform_.GetNoArena();
}
inline void LoginReq::set_platform(const ::std::string& value) {
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.platform)
}
#if LANG_CXX11
inline void LoginReq::set_platform(::std::string&& value) {
  set_has_platform();
  platform_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.LoginReq.platform)
}
#endif
inline void LoginReq::set_platform(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginReq.platform)
}
inline void LoginReq::set_platform(const char* value, size_t size) {
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginReq.platform)
}
inline ::std::string* LoginReq::mutable_platform() {
  set_has_platform();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginReq.platform)
  return platform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReq::release_platform() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.LoginReq.platform)
  clear_has_platform();
  return platform_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReq::set_allocated_platform(::std::string* platform) {
  if (platform != NULL) {
    set_has_platform();
  } else {
    clear_has_platform();
  }
  platform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginReq.platform)
}

// optional string verf_code = 9;
inline bool LoginReq::has_verf_code() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginReq::set_has_verf_code() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginReq::clear_has_verf_code() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginReq::clear_verf_code() {
  verf_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verf_code();
}
inline const ::std::string& LoginReq::verf_code() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.verf_code)
  return verf_code_.GetNoArena();
}
inline void LoginReq::set_verf_code(const ::std::string& value) {
  set_has_verf_code();
  verf_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.verf_code)
}
#if LANG_CXX11
inline void LoginReq::set_verf_code(::std::string&& value) {
  set_has_verf_code();
  verf_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.LoginReq.verf_code)
}
#endif
inline void LoginReq::set_verf_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verf_code();
  verf_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginReq.verf_code)
}
inline void LoginReq::set_verf_code(const char* value, size_t size) {
  set_has_verf_code();
  verf_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginReq.verf_code)
}
inline ::std::string* LoginReq::mutable_verf_code() {
  set_has_verf_code();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginReq.verf_code)
  return verf_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReq::release_verf_code() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.LoginReq.verf_code)
  clear_has_verf_code();
  return verf_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReq::set_allocated_verf_code(::std::string* verf_code) {
  if (verf_code != NULL) {
    set_has_verf_code();
  } else {
    clear_has_verf_code();
  }
  verf_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verf_code);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginReq.verf_code)
}

// optional bool not_encrypt = 10;
inline bool LoginReq::has_not_encrypt() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginReq::set_has_not_encrypt() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginReq::clear_has_not_encrypt() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginReq::clear_not_encrypt() {
  not_encrypt_ = false;
  clear_has_not_encrypt();
}
inline bool LoginReq::not_encrypt() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.not_encrypt)
  return not_encrypt_;
}
inline void LoginReq::set_not_encrypt(bool value) {
  set_has_not_encrypt();
  not_encrypt_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.not_encrypt)
}

// -------------------------------------------------------------------

// LoginResp

// required uint32 timestamp = 1;
inline bool LoginResp::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResp::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResp::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResp::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 LoginResp::timestamp() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginResp.timestamp)
  return timestamp_;
}
inline void LoginResp::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginResp.timestamp)
}

// required string session_id = 2;
inline bool LoginResp::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResp::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResp::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResp::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_session_id();
}
inline const ::std::string& LoginResp::session_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginResp.session_id)
  return session_id_.GetNoArena();
}
inline void LoginResp::set_session_id(const ::std::string& value) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginResp.session_id)
}
#if LANG_CXX11
inline void LoginResp::set_session_id(::std::string&& value) {
  set_has_session_id();
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.LoginResp.session_id)
}
#endif
inline void LoginResp::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginResp.session_id)
}
inline void LoginResp::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginResp.session_id)
}
inline ::std::string* LoginResp::mutable_session_id() {
  set_has_session_id();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginResp.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResp::release_session_id() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.LoginResp.session_id)
  clear_has_session_id();
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResp::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    set_has_session_id();
  } else {
    clear_has_session_id();
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginResp.session_id)
}

// required string session_key = 3;
inline bool LoginResp::has_session_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResp::set_has_session_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResp::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResp::clear_session_key() {
  session_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_session_key();
}
inline const ::std::string& LoginResp::session_key() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginResp.session_key)
  return session_key_.GetNoArena();
}
inline void LoginResp::set_session_key(const ::std::string& value) {
  set_has_session_key();
  session_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginResp.session_key)
}
#if LANG_CXX11
inline void LoginResp::set_session_key(::std::string&& value) {
  set_has_session_key();
  session_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.LoginResp.session_key)
}
#endif
inline void LoginResp::set_session_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_session_key();
  session_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginResp.session_key)
}
inline void LoginResp::set_session_key(const char* value, size_t size) {
  set_has_session_key();
  session_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginResp.session_key)
}
inline ::std::string* LoginResp::mutable_session_key() {
  set_has_session_key();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginResp.session_key)
  return session_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResp::release_session_key() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.LoginResp.session_key)
  clear_has_session_key();
  return session_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResp::set_allocated_session_key(::std::string* session_key) {
  if (session_key != NULL) {
    set_has_session_key();
  } else {
    clear_has_session_key();
  }
  session_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_key);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginResp.session_key)
}

// optional string client_login_ip = 4;
inline bool LoginResp::has_client_login_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResp::set_has_client_login_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResp::clear_has_client_login_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResp::clear_client_login_ip() {
  client_login_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_login_ip();
}
inline const ::std::string& LoginResp::client_login_ip() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginResp.client_login_ip)
  return client_login_ip_.GetNoArena();
}
inline void LoginResp::set_client_login_ip(const ::std::string& value) {
  set_has_client_login_ip();
  client_login_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginResp.client_login_ip)
}
#if LANG_CXX11
inline void LoginResp::set_client_login_ip(::std::string&& value) {
  set_has_client_login_ip();
  client_login_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.LoginResp.client_login_ip)
}
#endif
inline void LoginResp::set_client_login_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_login_ip();
  client_login_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginResp.client_login_ip)
}
inline void LoginResp::set_client_login_ip(const char* value, size_t size) {
  set_has_client_login_ip();
  client_login_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginResp.client_login_ip)
}
inline ::std::string* LoginResp::mutable_client_login_ip() {
  set_has_client_login_ip();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginResp.client_login_ip)
  return client_login_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResp::release_client_login_ip() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.LoginResp.client_login_ip)
  clear_has_client_login_ip();
  return client_login_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResp::set_allocated_client_login_ip(::std::string* client_login_ip) {
  if (client_login_ip != NULL) {
    set_has_client_login_ip();
  } else {
    clear_has_client_login_ip();
  }
  client_login_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_login_ip);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginResp.client_login_ip)
}

// optional string serverip = 5;
inline bool LoginResp::has_serverip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResp::set_has_serverip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResp::clear_has_serverip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResp::clear_serverip() {
  serverip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverip();
}
inline const ::std::string& LoginResp::serverip() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginResp.serverip)
  return serverip_.GetNoArena();
}
inline void LoginResp::set_serverip(const ::std::string& value) {
  set_has_serverip();
  serverip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginResp.serverip)
}
#if LANG_CXX11
inline void LoginResp::set_serverip(::std::string&& value) {
  set_has_serverip();
  serverip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.LoginResp.serverip)
}
#endif
inline void LoginResp::set_serverip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverip();
  serverip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginResp.serverip)
}
inline void LoginResp::set_serverip(const char* value, size_t size) {
  set_has_serverip();
  serverip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginResp.serverip)
}
inline ::std::string* LoginResp::mutable_serverip() {
  set_has_serverip();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginResp.serverip)
  return serverip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResp::release_serverip() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.LoginResp.serverip)
  clear_has_serverip();
  return serverip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResp::set_allocated_serverip(::std::string* serverip) {
  if (serverip != NULL) {
    set_has_serverip();
  } else {
    clear_has_serverip();
  }
  serverip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverip);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginResp.serverip)
}

// -------------------------------------------------------------------

// ChatReq

// required bytes body = 1;
inline bool ChatReq::has_body() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatReq::set_has_body() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatReq::clear_has_body() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatReq::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_body();
}
inline const ::std::string& ChatReq::body() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.body)
  return body_.GetNoArena();
}
inline void ChatReq::set_body(const ::std::string& value) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.body)
}
#if LANG_CXX11
inline void ChatReq::set_body(::std::string&& value) {
  set_has_body();
  body_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.ChatReq.body)
}
#endif
inline void ChatReq::set_body(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ChatReq.body)
}
inline void ChatReq::set_body(const void* value, size_t size) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ChatReq.body)
}
inline ::std::string* ChatReq::mutable_body() {
  set_has_body();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ChatReq.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatReq::release_body() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.ChatReq.body)
  clear_has_body();
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatReq::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    set_has_body();
  } else {
    clear_has_body();
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.ChatReq.body)
}

// optional uint32 body_id = 2;
inline bool ChatReq::has_body_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatReq::set_has_body_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatReq::clear_has_body_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatReq::clear_body_id() {
  body_id_ = 0u;
  clear_has_body_id();
}
inline ::google::protobuf::uint32 ChatReq::body_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.body_id)
  return body_id_;
}
inline void ChatReq::set_body_id(::google::protobuf::uint32 value) {
  set_has_body_id();
  body_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.body_id)
}

// optional uint32 more_flag = 3;
inline bool ChatReq::has_more_flag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChatReq::set_has_more_flag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChatReq::clear_has_more_flag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChatReq::clear_more_flag() {
  more_flag_ = 0u;
  clear_has_more_flag();
}
inline ::google::protobuf::uint32 ChatReq::more_flag() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.more_flag)
  return more_flag_;
}
inline void ChatReq::set_more_flag(::google::protobuf::uint32 value) {
  set_has_more_flag();
  more_flag_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.more_flag)
}

// required uint32 body_type = 4;
inline bool ChatReq::has_body_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChatReq::set_has_body_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChatReq::clear_has_body_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChatReq::clear_body_type() {
  body_type_ = 0u;
  clear_has_body_type();
}
inline ::google::protobuf::uint32 ChatReq::body_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.body_type)
  return body_type_;
}
inline void ChatReq::set_body_type(::google::protobuf::uint32 value) {
  set_has_body_type();
  body_type_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.body_type)
}

// optional bool store = 5;
inline bool ChatReq::has_store() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChatReq::set_has_store() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChatReq::clear_has_store() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChatReq::clear_store() {
  store_ = false;
  clear_has_store();
}
inline bool ChatReq::store() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.store)
  return store_;
}
inline void ChatReq::set_store(bool value) {
  set_has_store();
  store_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.store)
}

// optional bytes m_parameter = 6;
inline bool ChatReq::has_m_parameter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatReq::set_has_m_parameter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatReq::clear_has_m_parameter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatReq::clear_m_parameter() {
  m_parameter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_m_parameter();
}
inline const ::std::string& ChatReq::m_parameter() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.m_parameter)
  return m_parameter_.GetNoArena();
}
inline void ChatReq::set_m_parameter(const ::std::string& value) {
  set_has_m_parameter();
  m_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.m_parameter)
}
#if LANG_CXX11
inline void ChatReq::set_m_parameter(::std::string&& value) {
  set_has_m_parameter();
  m_parameter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.ChatReq.m_parameter)
}
#endif
inline void ChatReq::set_m_parameter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_m_parameter();
  m_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ChatReq.m_parameter)
}
inline void ChatReq::set_m_parameter(const void* value, size_t size) {
  set_has_m_parameter();
  m_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ChatReq.m_parameter)
}
inline ::std::string* ChatReq::mutable_m_parameter() {
  set_has_m_parameter();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ChatReq.m_parameter)
  return m_parameter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatReq::release_m_parameter() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.ChatReq.m_parameter)
  clear_has_m_parameter();
  return m_parameter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatReq::set_allocated_m_parameter(::std::string* m_parameter) {
  if (m_parameter != NULL) {
    set_has_m_parameter();
  } else {
    clear_has_m_parameter();
  }
  m_parameter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), m_parameter);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.ChatReq.m_parameter)
}

// optional uint32 service_id = 7;
inline bool ChatReq::has_service_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChatReq::set_has_service_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ChatReq::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ChatReq::clear_service_id() {
  service_id_ = 0u;
  clear_has_service_id();
}
inline ::google::protobuf::uint32 ChatReq::service_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.service_id)
  return service_id_;
}
inline void ChatReq::set_service_id(::google::protobuf::uint32 value) {
  set_has_service_id();
  service_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.service_id)
}

// optional bytes s_parameter = 8;
inline bool ChatReq::has_s_parameter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatReq::set_has_s_parameter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatReq::clear_has_s_parameter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatReq::clear_s_parameter() {
  s_parameter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_s_parameter();
}
inline const ::std::string& ChatReq::s_parameter() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.s_parameter)
  return s_parameter_.GetNoArena();
}
inline void ChatReq::set_s_parameter(const ::std::string& value) {
  set_has_s_parameter();
  s_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.s_parameter)
}
#if LANG_CXX11
inline void ChatReq::set_s_parameter(::std::string&& value) {
  set_has_s_parameter();
  s_parameter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.ChatReq.s_parameter)
}
#endif
inline void ChatReq::set_s_parameter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_s_parameter();
  s_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ChatReq.s_parameter)
}
inline void ChatReq::set_s_parameter(const void* value, size_t size) {
  set_has_s_parameter();
  s_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ChatReq.s_parameter)
}
inline ::std::string* ChatReq::mutable_s_parameter() {
  set_has_s_parameter();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ChatReq.s_parameter)
  return s_parameter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatReq::release_s_parameter() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.ChatReq.s_parameter)
  clear_has_s_parameter();
  return s_parameter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatReq::set_allocated_s_parameter(::std::string* s_parameter) {
  if (s_parameter != NULL) {
    set_has_s_parameter();
  } else {
    clear_has_s_parameter();
  }
  s_parameter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s_parameter);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.ChatReq.s_parameter)
}

// optional uint32 expire_time = 12;
inline bool ChatReq::has_expire_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ChatReq::set_has_expire_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ChatReq::clear_has_expire_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ChatReq::clear_expire_time() {
  expire_time_ = 0u;
  clear_has_expire_time();
}
inline ::google::protobuf::uint32 ChatReq::expire_time() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.expire_time)
  return expire_time_;
}
inline void ChatReq::set_expire_time(::google::protobuf::uint32 value) {
  set_has_expire_time();
  expire_time_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.expire_time)
}

// -------------------------------------------------------------------

// ChatResp

// required uint32 result = 1;
inline bool ChatResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatResp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 ChatResp::result() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatResp.result)
  return result_;
}
inline void ChatResp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatResp.result)
}

// optional uint32 body_id = 2;
inline bool ChatResp::has_body_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatResp::set_has_body_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatResp::clear_has_body_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatResp::clear_body_id() {
  body_id_ = 0u;
  clear_has_body_id();
}
inline ::google::protobuf::uint32 ChatResp::body_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatResp.body_id)
  return body_id_;
}
inline void ChatResp::set_body_id(::google::protobuf::uint32 value) {
  set_has_body_id();
  body_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatResp.body_id)
}

// -------------------------------------------------------------------

// GetInfoReq

// required string info_type = 1;
inline bool GetInfoReq::has_info_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetInfoReq::set_has_info_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetInfoReq::clear_has_info_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetInfoReq::clear_info_type() {
  info_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_info_type();
}
inline const ::std::string& GetInfoReq::info_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoReq.info_type)
  return info_type_.GetNoArena();
}
inline void GetInfoReq::set_info_type(const ::std::string& value) {
  set_has_info_type();
  info_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetInfoReq.info_type)
}
#if LANG_CXX11
inline void GetInfoReq::set_info_type(::std::string&& value) {
  set_has_info_type();
  info_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.GetInfoReq.info_type)
}
#endif
inline void GetInfoReq::set_info_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_info_type();
  info_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetInfoReq.info_type)
}
inline void GetInfoReq::set_info_type(const char* value, size_t size) {
  set_has_info_type();
  info_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetInfoReq.info_type)
}
inline ::std::string* GetInfoReq::mutable_info_type() {
  set_has_info_type();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetInfoReq.info_type)
  return info_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetInfoReq::release_info_type() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.GetInfoReq.info_type)
  clear_has_info_type();
  return info_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetInfoReq::set_allocated_info_type(::std::string* info_type) {
  if (info_type != NULL) {
    set_has_info_type();
  } else {
    clear_has_info_type();
  }
  info_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info_type);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetInfoReq.info_type)
}

// required int64 get_info_id = 2;
inline bool GetInfoReq::has_get_info_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetInfoReq::set_has_get_info_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetInfoReq::clear_has_get_info_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetInfoReq::clear_get_info_id() {
  get_info_id_ = GOOGLE_LONGLONG(0);
  clear_has_get_info_id();
}
inline ::google::protobuf::int64 GetInfoReq::get_info_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoReq.get_info_id)
  return get_info_id_;
}
inline void GetInfoReq::set_get_info_id(::google::protobuf::int64 value) {
  set_has_get_info_id();
  get_info_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetInfoReq.get_info_id)
}

// optional int32 get_info_offset = 3;
inline bool GetInfoReq::has_get_info_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetInfoReq::set_has_get_info_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetInfoReq::clear_has_get_info_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetInfoReq::clear_get_info_offset() {
  get_info_offset_ = 0;
  clear_has_get_info_offset();
}
inline ::google::protobuf::int32 GetInfoReq::get_info_offset() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoReq.get_info_offset)
  return get_info_offset_;
}
inline void GetInfoReq::set_get_info_offset(::google::protobuf::int32 value) {
  set_has_get_info_offset();
  get_info_offset_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetInfoReq.get_info_offset)
}

// optional bytes s_parameter = 4;
inline bool GetInfoReq::has_s_parameter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetInfoReq::set_has_s_parameter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetInfoReq::clear_has_s_parameter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetInfoReq::clear_s_parameter() {
  s_parameter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_s_parameter();
}
inline const ::std::string& GetInfoReq::s_parameter() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoReq.s_parameter)
  return s_parameter_.GetNoArena();
}
inline void GetInfoReq::set_s_parameter(const ::std::string& value) {
  set_has_s_parameter();
  s_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetInfoReq.s_parameter)
}
#if LANG_CXX11
inline void GetInfoReq::set_s_parameter(::std::string&& value) {
  set_has_s_parameter();
  s_parameter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.GetInfoReq.s_parameter)
}
#endif
inline void GetInfoReq::set_s_parameter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_s_parameter();
  s_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetInfoReq.s_parameter)
}
inline void GetInfoReq::set_s_parameter(const void* value, size_t size) {
  set_has_s_parameter();
  s_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetInfoReq.s_parameter)
}
inline ::std::string* GetInfoReq::mutable_s_parameter() {
  set_has_s_parameter();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetInfoReq.s_parameter)
  return s_parameter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetInfoReq::release_s_parameter() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.GetInfoReq.s_parameter)
  clear_has_s_parameter();
  return s_parameter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetInfoReq::set_allocated_s_parameter(::std::string* s_parameter) {
  if (s_parameter != NULL) {
    set_has_s_parameter();
  } else {
    clear_has_s_parameter();
  }
  s_parameter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s_parameter);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetInfoReq.s_parameter)
}

// -------------------------------------------------------------------

// GetInfoResp

// required string info_type = 1;
inline bool GetInfoResp::has_info_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetInfoResp::set_has_info_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetInfoResp::clear_has_info_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetInfoResp::clear_info_type() {
  info_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_info_type();
}
inline const ::std::string& GetInfoResp::info_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoResp.info_type)
  return info_type_.GetNoArena();
}
inline void GetInfoResp::set_info_type(const ::std::string& value) {
  set_has_info_type();
  info_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetInfoResp.info_type)
}
#if LANG_CXX11
inline void GetInfoResp::set_info_type(::std::string&& value) {
  set_has_info_type();
  info_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.GetInfoResp.info_type)
}
#endif
inline void GetInfoResp::set_info_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_info_type();
  info_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetInfoResp.info_type)
}
inline void GetInfoResp::set_info_type(const char* value, size_t size) {
  set_has_info_type();
  info_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetInfoResp.info_type)
}
inline ::std::string* GetInfoResp::mutable_info_type() {
  set_has_info_type();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetInfoResp.info_type)
  return info_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetInfoResp::release_info_type() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.GetInfoResp.info_type)
  clear_has_info_type();
  return info_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetInfoResp::set_allocated_info_type(::std::string* info_type) {
  if (info_type != NULL) {
    set_has_info_type();
  } else {
    clear_has_info_type();
  }
  info_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info_type);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetInfoResp.info_type)
}

// repeated .qihoo.protocol.messages.Info infos = 2;
inline int GetInfoResp::infos_size() const {
  return infos_.size();
}
inline void GetInfoResp::clear_infos() {
  infos_.Clear();
}
inline const ::qihoo::protocol::messages::Info& GetInfoResp::infos(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoResp.infos)
  return infos_.Get(index);
}
inline ::qihoo::protocol::messages::Info* GetInfoResp::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetInfoResp.infos)
  return infos_.Mutable(index);
}
inline ::qihoo::protocol::messages::Info* GetInfoResp::add_infos() {
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.GetInfoResp.infos)
  return infos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >*
GetInfoResp::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.GetInfoResp.infos)
  return &infos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >&
GetInfoResp::infos() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.GetInfoResp.infos)
  return infos_;
}

// optional int64 last_info_id = 3;
inline bool GetInfoResp::has_last_info_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetInfoResp::set_has_last_info_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetInfoResp::clear_has_last_info_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetInfoResp::clear_last_info_id() {
  last_info_id_ = GOOGLE_LONGLONG(0);
  clear_has_last_info_id();
}
inline ::google::protobuf::int64 GetInfoResp::last_info_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoResp.last_info_id)
  return last_info_id_;
}
inline void GetInfoResp::set_last_info_id(::google::protobuf::int64 value) {
  set_has_last_info_id();
  last_info_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetInfoResp.last_info_id)
}

// optional bytes s_parameter = 4;
inline bool GetInfoResp::has_s_parameter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetInfoResp::set_has_s_parameter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetInfoResp::clear_has_s_parameter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetInfoResp::clear_s_parameter() {
  s_parameter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_s_parameter();
}
inline const ::std::string& GetInfoResp::s_parameter() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoResp.s_parameter)
  return s_parameter_.GetNoArena();
}
inline void GetInfoResp::set_s_parameter(const ::std::string& value) {
  set_has_s_parameter();
  s_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetInfoResp.s_parameter)
}
#if LANG_CXX11
inline void GetInfoResp::set_s_parameter(::std::string&& value) {
  set_has_s_parameter();
  s_parameter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.GetInfoResp.s_parameter)
}
#endif
inline void GetInfoResp::set_s_parameter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_s_parameter();
  s_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetInfoResp.s_parameter)
}
inline void GetInfoResp::set_s_parameter(const void* value, size_t size) {
  set_has_s_parameter();
  s_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetInfoResp.s_parameter)
}
inline ::std::string* GetInfoResp::mutable_s_parameter() {
  set_has_s_parameter();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetInfoResp.s_parameter)
  return s_parameter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetInfoResp::release_s_parameter() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.GetInfoResp.s_parameter)
  clear_has_s_parameter();
  return s_parameter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetInfoResp::set_allocated_s_parameter(::std::string* s_parameter) {
  if (s_parameter != NULL) {
    set_has_s_parameter();
  } else {
    clear_has_s_parameter();
  }
  s_parameter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s_parameter);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetInfoResp.s_parameter)
}

// -------------------------------------------------------------------

// GetMultiInfosReq

// required string info_type = 1;
inline bool GetMultiInfosReq::has_info_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMultiInfosReq::set_has_info_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMultiInfosReq::clear_has_info_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMultiInfosReq::clear_info_type() {
  info_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_info_type();
}
inline const ::std::string& GetMultiInfosReq::info_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetMultiInfosReq.info_type)
  return info_type_.GetNoArena();
}
inline void GetMultiInfosReq::set_info_type(const ::std::string& value) {
  set_has_info_type();
  info_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetMultiInfosReq.info_type)
}
#if LANG_CXX11
inline void GetMultiInfosReq::set_info_type(::std::string&& value) {
  set_has_info_type();
  info_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.GetMultiInfosReq.info_type)
}
#endif
inline void GetMultiInfosReq::set_info_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_info_type();
  info_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetMultiInfosReq.info_type)
}
inline void GetMultiInfosReq::set_info_type(const char* value, size_t size) {
  set_has_info_type();
  info_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetMultiInfosReq.info_type)
}
inline ::std::string* GetMultiInfosReq::mutable_info_type() {
  set_has_info_type();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetMultiInfosReq.info_type)
  return info_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetMultiInfosReq::release_info_type() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.GetMultiInfosReq.info_type)
  clear_has_info_type();
  return info_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetMultiInfosReq::set_allocated_info_type(::std::string* info_type) {
  if (info_type != NULL) {
    set_has_info_type();
  } else {
    clear_has_info_type();
  }
  info_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info_type);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetMultiInfosReq.info_type)
}

// repeated int64 get_info_ids = 2;
inline int GetMultiInfosReq::get_info_ids_size() const {
  return get_info_ids_.size();
}
inline void GetMultiInfosReq::clear_get_info_ids() {
  get_info_ids_.Clear();
}
inline ::google::protobuf::int64 GetMultiInfosReq::get_info_ids(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetMultiInfosReq.get_info_ids)
  return get_info_ids_.Get(index);
}
inline void GetMultiInfosReq::set_get_info_ids(int index, ::google::protobuf::int64 value) {
  get_info_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetMultiInfosReq.get_info_ids)
}
inline void GetMultiInfosReq::add_get_info_ids(::google::protobuf::int64 value) {
  get_info_ids_.Add(value);
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.GetMultiInfosReq.get_info_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetMultiInfosReq::get_info_ids() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.GetMultiInfosReq.get_info_ids)
  return get_info_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetMultiInfosReq::mutable_get_info_ids() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.GetMultiInfosReq.get_info_ids)
  return &get_info_ids_;
}

// optional bytes s_parameter = 3;
inline bool GetMultiInfosReq::has_s_parameter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetMultiInfosReq::set_has_s_parameter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetMultiInfosReq::clear_has_s_parameter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetMultiInfosReq::clear_s_parameter() {
  s_parameter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_s_parameter();
}
inline const ::std::string& GetMultiInfosReq::s_parameter() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetMultiInfosReq.s_parameter)
  return s_parameter_.GetNoArena();
}
inline void GetMultiInfosReq::set_s_parameter(const ::std::string& value) {
  set_has_s_parameter();
  s_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetMultiInfosReq.s_parameter)
}
#if LANG_CXX11
inline void GetMultiInfosReq::set_s_parameter(::std::string&& value) {
  set_has_s_parameter();
  s_parameter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.GetMultiInfosReq.s_parameter)
}
#endif
inline void GetMultiInfosReq::set_s_parameter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_s_parameter();
  s_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetMultiInfosReq.s_parameter)
}
inline void GetMultiInfosReq::set_s_parameter(const void* value, size_t size) {
  set_has_s_parameter();
  s_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetMultiInfosReq.s_parameter)
}
inline ::std::string* GetMultiInfosReq::mutable_s_parameter() {
  set_has_s_parameter();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetMultiInfosReq.s_parameter)
  return s_parameter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetMultiInfosReq::release_s_parameter() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.GetMultiInfosReq.s_parameter)
  clear_has_s_parameter();
  return s_parameter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetMultiInfosReq::set_allocated_s_parameter(::std::string* s_parameter) {
  if (s_parameter != NULL) {
    set_has_s_parameter();
  } else {
    clear_has_s_parameter();
  }
  s_parameter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s_parameter);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetMultiInfosReq.s_parameter)
}

// -------------------------------------------------------------------

// GetMultiInfosResp

// required string info_type = 1;
inline bool GetMultiInfosResp::has_info_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMultiInfosResp::set_has_info_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMultiInfosResp::clear_has_info_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMultiInfosResp::clear_info_type() {
  info_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_info_type();
}
inline const ::std::string& GetMultiInfosResp::info_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetMultiInfosResp.info_type)
  return info_type_.GetNoArena();
}
inline void GetMultiInfosResp::set_info_type(const ::std::string& value) {
  set_has_info_type();
  info_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetMultiInfosResp.info_type)
}
#if LANG_CXX11
inline void GetMultiInfosResp::set_info_type(::std::string&& value) {
  set_has_info_type();
  info_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.GetMultiInfosResp.info_type)
}
#endif
inline void GetMultiInfosResp::set_info_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_info_type();
  info_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetMultiInfosResp.info_type)
}
inline void GetMultiInfosResp::set_info_type(const char* value, size_t size) {
  set_has_info_type();
  info_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetMultiInfosResp.info_type)
}
inline ::std::string* GetMultiInfosResp::mutable_info_type() {
  set_has_info_type();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetMultiInfosResp.info_type)
  return info_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetMultiInfosResp::release_info_type() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.GetMultiInfosResp.info_type)
  clear_has_info_type();
  return info_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetMultiInfosResp::set_allocated_info_type(::std::string* info_type) {
  if (info_type != NULL) {
    set_has_info_type();
  } else {
    clear_has_info_type();
  }
  info_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info_type);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetMultiInfosResp.info_type)
}

// repeated .qihoo.protocol.messages.Info infos = 2;
inline int GetMultiInfosResp::infos_size() const {
  return infos_.size();
}
inline void GetMultiInfosResp::clear_infos() {
  infos_.Clear();
}
inline const ::qihoo::protocol::messages::Info& GetMultiInfosResp::infos(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetMultiInfosResp.infos)
  return infos_.Get(index);
}
inline ::qihoo::protocol::messages::Info* GetMultiInfosResp::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetMultiInfosResp.infos)
  return infos_.Mutable(index);
}
inline ::qihoo::protocol::messages::Info* GetMultiInfosResp::add_infos() {
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.GetMultiInfosResp.infos)
  return infos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >*
GetMultiInfosResp::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.GetMultiInfosResp.infos)
  return &infos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >&
GetMultiInfosResp::infos() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.GetMultiInfosResp.infos)
  return infos_;
}

// optional int64 last_info_id = 3;
inline bool GetMultiInfosResp::has_last_info_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetMultiInfosResp::set_has_last_info_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetMultiInfosResp::clear_has_last_info_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetMultiInfosResp::clear_last_info_id() {
  last_info_id_ = GOOGLE_LONGLONG(0);
  clear_has_last_info_id();
}
inline ::google::protobuf::int64 GetMultiInfosResp::last_info_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetMultiInfosResp.last_info_id)
  return last_info_id_;
}
inline void GetMultiInfosResp::set_last_info_id(::google::protobuf::int64 value) {
  set_has_last_info_id();
  last_info_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetMultiInfosResp.last_info_id)
}

// optional bytes s_parameter = 4;
inline bool GetMultiInfosResp::has_s_parameter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetMultiInfosResp::set_has_s_parameter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetMultiInfosResp::clear_has_s_parameter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetMultiInfosResp::clear_s_parameter() {
  s_parameter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_s_parameter();
}
inline const ::std::string& GetMultiInfosResp::s_parameter() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetMultiInfosResp.s_parameter)
  return s_parameter_.GetNoArena();
}
inline void GetMultiInfosResp::set_s_parameter(const ::std::string& value) {
  set_has_s_parameter();
  s_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetMultiInfosResp.s_parameter)
}
#if LANG_CXX11
inline void GetMultiInfosResp::set_s_parameter(::std::string&& value) {
  set_has_s_parameter();
  s_parameter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.GetMultiInfosResp.s_parameter)
}
#endif
inline void GetMultiInfosResp::set_s_parameter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_s_parameter();
  s_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetMultiInfosResp.s_parameter)
}
inline void GetMultiInfosResp::set_s_parameter(const void* value, size_t size) {
  set_has_s_parameter();
  s_parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetMultiInfosResp.s_parameter)
}
inline ::std::string* GetMultiInfosResp::mutable_s_parameter() {
  set_has_s_parameter();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetMultiInfosResp.s_parameter)
  return s_parameter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetMultiInfosResp::release_s_parameter() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.GetMultiInfosResp.s_parameter)
  clear_has_s_parameter();
  return s_parameter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetMultiInfosResp::set_allocated_s_parameter(::std::string* s_parameter) {
  if (s_parameter != NULL) {
    set_has_s_parameter();
  } else {
    clear_has_s_parameter();
  }
  s_parameter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s_parameter);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetMultiInfosResp.s_parameter)
}

// -------------------------------------------------------------------

// LogoutReq

// optional string reason = 1;
inline bool LogoutReq::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutReq::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutReq::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutReq::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reason();
}
inline const ::std::string& LogoutReq::reason() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LogoutReq.reason)
  return reason_.GetNoArena();
}
inline void LogoutReq::set_reason(const ::std::string& value) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LogoutReq.reason)
}
#if LANG_CXX11
inline void LogoutReq::set_reason(::std::string&& value) {
  set_has_reason();
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.LogoutReq.reason)
}
#endif
inline void LogoutReq::set_reason(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LogoutReq.reason)
}
inline void LogoutReq::set_reason(const char* value, size_t size) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LogoutReq.reason)
}
inline ::std::string* LogoutReq::mutable_reason() {
  set_has_reason();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LogoutReq.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogoutReq::release_reason() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.LogoutReq.reason)
  clear_has_reason();
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogoutReq::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    set_has_reason();
  } else {
    clear_has_reason();
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LogoutReq.reason)
}

// -------------------------------------------------------------------

// LogoutResp

// required uint32 result = 1;
inline bool LogoutResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutResp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 LogoutResp::result() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LogoutResp.result)
  return result_;
}
inline void LogoutResp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LogoutResp.result)
}

// -------------------------------------------------------------------

// InitLoginReq

// required string client_ram = 1;
inline bool InitLoginReq::has_client_ram() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitLoginReq::set_has_client_ram() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitLoginReq::clear_has_client_ram() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitLoginReq::clear_client_ram() {
  client_ram_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_ram();
}
inline const ::std::string& InitLoginReq::client_ram() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.InitLoginReq.client_ram)
  return client_ram_.GetNoArena();
}
inline void InitLoginReq::set_client_ram(const ::std::string& value) {
  set_has_client_ram();
  client_ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.InitLoginReq.client_ram)
}
#if LANG_CXX11
inline void InitLoginReq::set_client_ram(::std::string&& value) {
  set_has_client_ram();
  client_ram_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.InitLoginReq.client_ram)
}
#endif
inline void InitLoginReq::set_client_ram(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_ram();
  client_ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.InitLoginReq.client_ram)
}
inline void InitLoginReq::set_client_ram(const char* value, size_t size) {
  set_has_client_ram();
  client_ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.InitLoginReq.client_ram)
}
inline ::std::string* InitLoginReq::mutable_client_ram() {
  set_has_client_ram();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.InitLoginReq.client_ram)
  return client_ram_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitLoginReq::release_client_ram() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.InitLoginReq.client_ram)
  clear_has_client_ram();
  return client_ram_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitLoginReq::set_allocated_client_ram(::std::string* client_ram) {
  if (client_ram != NULL) {
    set_has_client_ram();
  } else {
    clear_has_client_ram();
  }
  client_ram_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_ram);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.InitLoginReq.client_ram)
}

// optional string sig = 2;
inline bool InitLoginReq::has_sig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitLoginReq::set_has_sig() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitLoginReq::clear_has_sig() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitLoginReq::clear_sig() {
  sig_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sig();
}
inline const ::std::string& InitLoginReq::sig() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.InitLoginReq.sig)
  return sig_.GetNoArena();
}
inline void InitLoginReq::set_sig(const ::std::string& value) {
  set_has_sig();
  sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.InitLoginReq.sig)
}
#if LANG_CXX11
inline void InitLoginReq::set_sig(::std::string&& value) {
  set_has_sig();
  sig_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.InitLoginReq.sig)
}
#endif
inline void InitLoginReq::set_sig(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sig();
  sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.InitLoginReq.sig)
}
inline void InitLoginReq::set_sig(const char* value, size_t size) {
  set_has_sig();
  sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.InitLoginReq.sig)
}
inline ::std::string* InitLoginReq::mutable_sig() {
  set_has_sig();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.InitLoginReq.sig)
  return sig_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitLoginReq::release_sig() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.InitLoginReq.sig)
  clear_has_sig();
  return sig_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitLoginReq::set_allocated_sig(::std::string* sig) {
  if (sig != NULL) {
    set_has_sig();
  } else {
    clear_has_sig();
  }
  sig_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sig);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.InitLoginReq.sig)
}

// -------------------------------------------------------------------

// InitLoginResp

// required string client_ram = 1;
inline bool InitLoginResp::has_client_ram() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitLoginResp::set_has_client_ram() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitLoginResp::clear_has_client_ram() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitLoginResp::clear_client_ram() {
  client_ram_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_ram();
}
inline const ::std::string& InitLoginResp::client_ram() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.InitLoginResp.client_ram)
  return client_ram_.GetNoArena();
}
inline void InitLoginResp::set_client_ram(const ::std::string& value) {
  set_has_client_ram();
  client_ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.InitLoginResp.client_ram)
}
#if LANG_CXX11
inline void InitLoginResp::set_client_ram(::std::string&& value) {
  set_has_client_ram();
  client_ram_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.InitLoginResp.client_ram)
}
#endif
inline void InitLoginResp::set_client_ram(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_ram();
  client_ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.InitLoginResp.client_ram)
}
inline void InitLoginResp::set_client_ram(const char* value, size_t size) {
  set_has_client_ram();
  client_ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.InitLoginResp.client_ram)
}
inline ::std::string* InitLoginResp::mutable_client_ram() {
  set_has_client_ram();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.InitLoginResp.client_ram)
  return client_ram_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitLoginResp::release_client_ram() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.InitLoginResp.client_ram)
  clear_has_client_ram();
  return client_ram_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitLoginResp::set_allocated_client_ram(::std::string* client_ram) {
  if (client_ram != NULL) {
    set_has_client_ram();
  } else {
    clear_has_client_ram();
  }
  client_ram_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_ram);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.InitLoginResp.client_ram)
}

// required string server_ram = 2;
inline bool InitLoginResp::has_server_ram() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitLoginResp::set_has_server_ram() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitLoginResp::clear_has_server_ram() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitLoginResp::clear_server_ram() {
  server_ram_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_server_ram();
}
inline const ::std::string& InitLoginResp::server_ram() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.InitLoginResp.server_ram)
  return server_ram_.GetNoArena();
}
inline void InitLoginResp::set_server_ram(const ::std::string& value) {
  set_has_server_ram();
  server_ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.InitLoginResp.server_ram)
}
#if LANG_CXX11
inline void InitLoginResp::set_server_ram(::std::string&& value) {
  set_has_server_ram();
  server_ram_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.InitLoginResp.server_ram)
}
#endif
inline void InitLoginResp::set_server_ram(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_server_ram();
  server_ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.InitLoginResp.server_ram)
}
inline void InitLoginResp::set_server_ram(const char* value, size_t size) {
  set_has_server_ram();
  server_ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.InitLoginResp.server_ram)
}
inline ::std::string* InitLoginResp::mutable_server_ram() {
  set_has_server_ram();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.InitLoginResp.server_ram)
  return server_ram_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitLoginResp::release_server_ram() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.InitLoginResp.server_ram)
  clear_has_server_ram();
  return server_ram_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitLoginResp::set_allocated_server_ram(::std::string* server_ram) {
  if (server_ram != NULL) {
    set_has_server_ram();
  } else {
    clear_has_server_ram();
  }
  server_ram_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_ram);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.InitLoginResp.server_ram)
}

// -------------------------------------------------------------------

// Service_Req

// required uint32 service_id = 1;
inline bool Service_Req::has_service_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Service_Req::set_has_service_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Service_Req::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Service_Req::clear_service_id() {
  service_id_ = 0u;
  clear_has_service_id();
}
inline ::google::protobuf::uint32 Service_Req::service_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Service_Req.service_id)
  return service_id_;
}
inline void Service_Req::set_service_id(::google::protobuf::uint32 value) {
  set_has_service_id();
  service_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Service_Req.service_id)
}

// required bytes request = 2;
inline bool Service_Req::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Service_Req::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Service_Req::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Service_Req::clear_request() {
  request_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_request();
}
inline const ::std::string& Service_Req::request() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Service_Req.request)
  return request_.GetNoArena();
}
inline void Service_Req::set_request(const ::std::string& value) {
  set_has_request();
  request_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Service_Req.request)
}
#if LANG_CXX11
inline void Service_Req::set_request(::std::string&& value) {
  set_has_request();
  request_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.Service_Req.request)
}
#endif
inline void Service_Req::set_request(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_request();
  request_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Service_Req.request)
}
inline void Service_Req::set_request(const void* value, size_t size) {
  set_has_request();
  request_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Service_Req.request)
}
inline ::std::string* Service_Req::mutable_request() {
  set_has_request();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Service_Req.request)
  return request_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Service_Req::release_request() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Service_Req.request)
  clear_has_request();
  return request_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Service_Req::set_allocated_request(::std::string* request) {
  if (request != NULL) {
    set_has_request();
  } else {
    clear_has_request();
  }
  request_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Service_Req.request)
}

// -------------------------------------------------------------------

// Service_Resp

// required uint32 service_id = 1;
inline bool Service_Resp::has_service_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Service_Resp::set_has_service_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Service_Resp::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Service_Resp::clear_service_id() {
  service_id_ = 0u;
  clear_has_service_id();
}
inline ::google::protobuf::uint32 Service_Resp::service_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Service_Resp.service_id)
  return service_id_;
}
inline void Service_Resp::set_service_id(::google::protobuf::uint32 value) {
  set_has_service_id();
  service_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Service_Resp.service_id)
}

// required bytes response = 2;
inline bool Service_Resp::has_response() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Service_Resp::set_has_response() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Service_Resp::clear_has_response() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Service_Resp::clear_response() {
  response_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_response();
}
inline const ::std::string& Service_Resp::response() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Service_Resp.response)
  return response_.GetNoArena();
}
inline void Service_Resp::set_response(const ::std::string& value) {
  set_has_response();
  response_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Service_Resp.response)
}
#if LANG_CXX11
inline void Service_Resp::set_response(::std::string&& value) {
  set_has_response();
  response_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.Service_Resp.response)
}
#endif
inline void Service_Resp::set_response(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_response();
  response_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Service_Resp.response)
}
inline void Service_Resp::set_response(const void* value, size_t size) {
  set_has_response();
  response_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Service_Resp.response)
}
inline ::std::string* Service_Resp::mutable_response() {
  set_has_response();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Service_Resp.response)
  return response_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Service_Resp::release_response() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Service_Resp.response)
  clear_has_response();
  return response_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Service_Resp::set_allocated_response(::std::string* response) {
  if (response != NULL) {
    set_has_response();
  } else {
    clear_has_response();
  }
  response_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), response);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Service_Resp.response)
}

// -------------------------------------------------------------------

// ReqEQ1User

// required string userid = 1;
inline bool ReqEQ1User::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqEQ1User::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqEQ1User::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqEQ1User::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_userid();
}
inline const ::std::string& ReqEQ1User::userid() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ReqEQ1User.userid)
  return userid_.GetNoArena();
}
inline void ReqEQ1User::set_userid(const ::std::string& value) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ReqEQ1User.userid)
}
#if LANG_CXX11
inline void ReqEQ1User::set_userid(::std::string&& value) {
  set_has_userid();
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.ReqEQ1User.userid)
}
#endif
inline void ReqEQ1User::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ReqEQ1User.userid)
}
inline void ReqEQ1User::set_userid(const char* value, size_t size) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ReqEQ1User.userid)
}
inline ::std::string* ReqEQ1User::mutable_userid() {
  set_has_userid();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ReqEQ1User.userid)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqEQ1User::release_userid() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.ReqEQ1User.userid)
  clear_has_userid();
  return userid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqEQ1User::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.ReqEQ1User.userid)
}

// required string user_type = 2;
inline bool ReqEQ1User::has_user_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqEQ1User::set_has_user_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqEQ1User::clear_has_user_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqEQ1User::clear_user_type() {
  user_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_type();
}
inline const ::std::string& ReqEQ1User::user_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ReqEQ1User.user_type)
  return user_type_.GetNoArena();
}
inline void ReqEQ1User::set_user_type(const ::std::string& value) {
  set_has_user_type();
  user_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ReqEQ1User.user_type)
}
#if LANG_CXX11
inline void ReqEQ1User::set_user_type(::std::string&& value) {
  set_has_user_type();
  user_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.ReqEQ1User.user_type)
}
#endif
inline void ReqEQ1User::set_user_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_type();
  user_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ReqEQ1User.user_type)
}
inline void ReqEQ1User::set_user_type(const char* value, size_t size) {
  set_has_user_type();
  user_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ReqEQ1User.user_type)
}
inline ::std::string* ReqEQ1User::mutable_user_type() {
  set_has_user_type();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ReqEQ1User.user_type)
  return user_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReqEQ1User::release_user_type() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.ReqEQ1User.user_type)
  clear_has_user_type();
  return user_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReqEQ1User::set_allocated_user_type(::std::string* user_type) {
  if (user_type != NULL) {
    set_has_user_type();
  } else {
    clear_has_user_type();
  }
  user_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_type);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.ReqEQ1User.user_type)
}

// optional uint32 app_id = 3;
inline bool ReqEQ1User::has_app_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqEQ1User::set_has_app_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqEQ1User::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqEQ1User::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 ReqEQ1User::app_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ReqEQ1User.app_id)
  return app_id_;
}
inline void ReqEQ1User::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ReqEQ1User.app_id)
}

// -------------------------------------------------------------------

// RespEQ1User

// required string userid = 1;
inline bool RespEQ1User::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespEQ1User::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespEQ1User::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespEQ1User::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_userid();
}
inline const ::std::string& RespEQ1User::userid() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.userid)
  return userid_.GetNoArena();
}
inline void RespEQ1User::set_userid(const ::std::string& value) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.userid)
}
#if LANG_CXX11
inline void RespEQ1User::set_userid(::std::string&& value) {
  set_has_userid();
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.RespEQ1User.userid)
}
#endif
inline void RespEQ1User::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RespEQ1User.userid)
}
inline void RespEQ1User::set_userid(const char* value, size_t size) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RespEQ1User.userid)
}
inline ::std::string* RespEQ1User::mutable_userid() {
  set_has_userid();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RespEQ1User.userid)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RespEQ1User::release_userid() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.RespEQ1User.userid)
  clear_has_userid();
  return userid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RespEQ1User::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RespEQ1User.userid)
}

// required string user_type = 2;
inline bool RespEQ1User::has_user_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RespEQ1User::set_has_user_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RespEQ1User::clear_has_user_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RespEQ1User::clear_user_type() {
  user_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_type();
}
inline const ::std::string& RespEQ1User::user_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.user_type)
  return user_type_.GetNoArena();
}
inline void RespEQ1User::set_user_type(const ::std::string& value) {
  set_has_user_type();
  user_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.user_type)
}
#if LANG_CXX11
inline void RespEQ1User::set_user_type(::std::string&& value) {
  set_has_user_type();
  user_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.RespEQ1User.user_type)
}
#endif
inline void RespEQ1User::set_user_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_type();
  user_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RespEQ1User.user_type)
}
inline void RespEQ1User::set_user_type(const char* value, size_t size) {
  set_has_user_type();
  user_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RespEQ1User.user_type)
}
inline ::std::string* RespEQ1User::mutable_user_type() {
  set_has_user_type();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RespEQ1User.user_type)
  return user_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RespEQ1User::release_user_type() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.RespEQ1User.user_type)
  clear_has_user_type();
  return user_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RespEQ1User::set_allocated_user_type(::std::string* user_type) {
  if (user_type != NULL) {
    set_has_user_type();
  } else {
    clear_has_user_type();
  }
  user_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_type);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RespEQ1User.user_type)
}

// required int32 status = 3;
inline bool RespEQ1User::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RespEQ1User::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RespEQ1User::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RespEQ1User::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 RespEQ1User::status() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.status)
  return status_;
}
inline void RespEQ1User::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.status)
}

// optional string jid = 4;
inline bool RespEQ1User::has_jid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RespEQ1User::set_has_jid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RespEQ1User::clear_has_jid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RespEQ1User::clear_jid() {
  jid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_jid();
}
inline const ::std::string& RespEQ1User::jid() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.jid)
  return jid_.GetNoArena();
}
inline void RespEQ1User::set_jid(const ::std::string& value) {
  set_has_jid();
  jid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.jid)
}
#if LANG_CXX11
inline void RespEQ1User::set_jid(::std::string&& value) {
  set_has_jid();
  jid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.RespEQ1User.jid)
}
#endif
inline void RespEQ1User::set_jid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_jid();
  jid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RespEQ1User.jid)
}
inline void RespEQ1User::set_jid(const char* value, size_t size) {
  set_has_jid();
  jid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RespEQ1User.jid)
}
inline ::std::string* RespEQ1User::mutable_jid() {
  set_has_jid();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RespEQ1User.jid)
  return jid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RespEQ1User::release_jid() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.RespEQ1User.jid)
  clear_has_jid();
  return jid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RespEQ1User::set_allocated_jid(::std::string* jid) {
  if (jid != NULL) {
    set_has_jid();
  } else {
    clear_has_jid();
  }
  jid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), jid);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RespEQ1User.jid)
}

// optional uint32 app_id = 5;
inline bool RespEQ1User::has_app_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RespEQ1User::set_has_app_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RespEQ1User::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RespEQ1User::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 RespEQ1User::app_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.app_id)
  return app_id_;
}
inline void RespEQ1User::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.app_id)
}

// optional string platform = 6;
inline bool RespEQ1User::has_platform() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RespEQ1User::set_has_platform() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RespEQ1User::clear_has_platform() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RespEQ1User::clear_platform() {
  platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_platform();
}
inline const ::std::string& RespEQ1User::platform() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.platform)
  return platform_.GetNoArena();
}
inline void RespEQ1User::set_platform(const ::std::string& value) {
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.platform)
}
#if LANG_CXX11
inline void RespEQ1User::set_platform(::std::string&& value) {
  set_has_platform();
  platform_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.RespEQ1User.platform)
}
#endif
inline void RespEQ1User::set_platform(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RespEQ1User.platform)
}
inline void RespEQ1User::set_platform(const char* value, size_t size) {
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RespEQ1User.platform)
}
inline ::std::string* RespEQ1User::mutable_platform() {
  set_has_platform();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RespEQ1User.platform)
  return platform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RespEQ1User::release_platform() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.RespEQ1User.platform)
  clear_has_platform();
  return platform_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RespEQ1User::set_allocated_platform(::std::string* platform) {
  if (platform != NULL) {
    set_has_platform();
  } else {
    clear_has_platform();
  }
  platform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RespEQ1User.platform)
}

// optional string mobile_type = 7;
inline bool RespEQ1User::has_mobile_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RespEQ1User::set_has_mobile_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RespEQ1User::clear_has_mobile_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RespEQ1User::clear_mobile_type() {
  mobile_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mobile_type();
}
inline const ::std::string& RespEQ1User::mobile_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.mobile_type)
  return mobile_type_.GetNoArena();
}
inline void RespEQ1User::set_mobile_type(const ::std::string& value) {
  set_has_mobile_type();
  mobile_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.mobile_type)
}
#if LANG_CXX11
inline void RespEQ1User::set_mobile_type(::std::string&& value) {
  set_has_mobile_type();
  mobile_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.RespEQ1User.mobile_type)
}
#endif
inline void RespEQ1User::set_mobile_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mobile_type();
  mobile_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RespEQ1User.mobile_type)
}
inline void RespEQ1User::set_mobile_type(const char* value, size_t size) {
  set_has_mobile_type();
  mobile_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RespEQ1User.mobile_type)
}
inline ::std::string* RespEQ1User::mutable_mobile_type() {
  set_has_mobile_type();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RespEQ1User.mobile_type)
  return mobile_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RespEQ1User::release_mobile_type() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.RespEQ1User.mobile_type)
  clear_has_mobile_type();
  return mobile_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RespEQ1User::set_allocated_mobile_type(::std::string* mobile_type) {
  if (mobile_type != NULL) {
    set_has_mobile_type();
  } else {
    clear_has_mobile_type();
  }
  mobile_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mobile_type);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RespEQ1User.mobile_type)
}

// optional uint32 client_ver = 8;
inline bool RespEQ1User::has_client_ver() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RespEQ1User::set_has_client_ver() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RespEQ1User::clear_has_client_ver() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RespEQ1User::clear_client_ver() {
  client_ver_ = 0u;
  clear_has_client_ver();
}
inline ::google::protobuf::uint32 RespEQ1User::client_ver() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.client_ver)
  return client_ver_;
}
inline void RespEQ1User::set_client_ver(::google::protobuf::uint32 value) {
  set_has_client_ver();
  client_ver_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.client_ver)
}

// -------------------------------------------------------------------

// Ex1QueryUserStatusReq

// repeated .qihoo.protocol.messages.ReqEQ1User user_list = 1;
inline int Ex1QueryUserStatusReq::user_list_size() const {
  return user_list_.size();
}
inline void Ex1QueryUserStatusReq::clear_user_list() {
  user_list_.Clear();
}
inline const ::qihoo::protocol::messages::ReqEQ1User& Ex1QueryUserStatusReq::user_list(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Ex1QueryUserStatusReq.user_list)
  return user_list_.Get(index);
}
inline ::qihoo::protocol::messages::ReqEQ1User* Ex1QueryUserStatusReq::mutable_user_list(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Ex1QueryUserStatusReq.user_list)
  return user_list_.Mutable(index);
}
inline ::qihoo::protocol::messages::ReqEQ1User* Ex1QueryUserStatusReq::add_user_list() {
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.Ex1QueryUserStatusReq.user_list)
  return user_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::ReqEQ1User >*
Ex1QueryUserStatusReq::mutable_user_list() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.Ex1QueryUserStatusReq.user_list)
  return &user_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::ReqEQ1User >&
Ex1QueryUserStatusReq::user_list() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.Ex1QueryUserStatusReq.user_list)
  return user_list_;
}

// -------------------------------------------------------------------

// Ex1QueryUserStatusResp

// repeated .qihoo.protocol.messages.RespEQ1User user_list = 1;
inline int Ex1QueryUserStatusResp::user_list_size() const {
  return user_list_.size();
}
inline void Ex1QueryUserStatusResp::clear_user_list() {
  user_list_.Clear();
}
inline const ::qihoo::protocol::messages::RespEQ1User& Ex1QueryUserStatusResp::user_list(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Ex1QueryUserStatusResp.user_list)
  return user_list_.Get(index);
}
inline ::qihoo::protocol::messages::RespEQ1User* Ex1QueryUserStatusResp::mutable_user_list(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Ex1QueryUserStatusResp.user_list)
  return user_list_.Mutable(index);
}
inline ::qihoo::protocol::messages::RespEQ1User* Ex1QueryUserStatusResp::add_user_list() {
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.Ex1QueryUserStatusResp.user_list)
  return user_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RespEQ1User >*
Ex1QueryUserStatusResp::mutable_user_list() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.Ex1QueryUserStatusResp.user_list)
  return &user_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RespEQ1User >&
Ex1QueryUserStatusResp::user_list() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.Ex1QueryUserStatusResp.user_list)
  return user_list_;
}

// -------------------------------------------------------------------

// Request

// optional .qihoo.protocol.messages.LoginReq login = 2;
inline bool Request::has_login() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_login() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_login() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_login() {
  if (login_ != NULL) login_->::qihoo::protocol::messages::LoginReq::Clear();
  clear_has_login();
}
inline const ::qihoo::protocol::messages::LoginReq& Request::login() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.login)
  return login_ != NULL ? *login_
                         : *::qihoo::protocol::messages::LoginReq::internal_default_instance();
}
inline ::qihoo::protocol::messages::LoginReq* Request::mutable_login() {
  set_has_login();
  if (login_ == NULL) {
    login_ = new ::qihoo::protocol::messages::LoginReq;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.login)
  return login_;
}
inline ::qihoo::protocol::messages::LoginReq* Request::release_login() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Request.login)
  clear_has_login();
  ::qihoo::protocol::messages::LoginReq* temp = login_;
  login_ = NULL;
  return temp;
}
inline void Request::set_allocated_login(::qihoo::protocol::messages::LoginReq* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.login)
}

// optional .qihoo.protocol.messages.ChatReq chat = 3;
inline bool Request::has_chat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_chat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_chat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_chat() {
  if (chat_ != NULL) chat_->::qihoo::protocol::messages::ChatReq::Clear();
  clear_has_chat();
}
inline const ::qihoo::protocol::messages::ChatReq& Request::chat() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.chat)
  return chat_ != NULL ? *chat_
                         : *::qihoo::protocol::messages::ChatReq::internal_default_instance();
}
inline ::qihoo::protocol::messages::ChatReq* Request::mutable_chat() {
  set_has_chat();
  if (chat_ == NULL) {
    chat_ = new ::qihoo::protocol::messages::ChatReq;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.chat)
  return chat_;
}
inline ::qihoo::protocol::messages::ChatReq* Request::release_chat() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Request.chat)
  clear_has_chat();
  ::qihoo::protocol::messages::ChatReq* temp = chat_;
  chat_ = NULL;
  return temp;
}
inline void Request::set_allocated_chat(::qihoo::protocol::messages::ChatReq* chat) {
  delete chat_;
  chat_ = chat;
  if (chat) {
    set_has_chat();
  } else {
    clear_has_chat();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.chat)
}

// optional .qihoo.protocol.messages.GetInfoReq get_info = 5;
inline bool Request::has_get_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_get_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_get_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_get_info() {
  if (get_info_ != NULL) get_info_->::qihoo::protocol::messages::GetInfoReq::Clear();
  clear_has_get_info();
}
inline const ::qihoo::protocol::messages::GetInfoReq& Request::get_info() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.get_info)
  return get_info_ != NULL ? *get_info_
                         : *::qihoo::protocol::messages::GetInfoReq::internal_default_instance();
}
inline ::qihoo::protocol::messages::GetInfoReq* Request::mutable_get_info() {
  set_has_get_info();
  if (get_info_ == NULL) {
    get_info_ = new ::qihoo::protocol::messages::GetInfoReq;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.get_info)
  return get_info_;
}
inline ::qihoo::protocol::messages::GetInfoReq* Request::release_get_info() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Request.get_info)
  clear_has_get_info();
  ::qihoo::protocol::messages::GetInfoReq* temp = get_info_;
  get_info_ = NULL;
  return temp;
}
inline void Request::set_allocated_get_info(::qihoo::protocol::messages::GetInfoReq* get_info) {
  delete get_info_;
  get_info_ = get_info;
  if (get_info) {
    set_has_get_info();
  } else {
    clear_has_get_info();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.get_info)
}

// optional .qihoo.protocol.messages.LogoutReq logout = 6;
inline bool Request::has_logout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_logout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_logout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_logout() {
  if (logout_ != NULL) logout_->::qihoo::protocol::messages::LogoutReq::Clear();
  clear_has_logout();
}
inline const ::qihoo::protocol::messages::LogoutReq& Request::logout() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.logout)
  return logout_ != NULL ? *logout_
                         : *::qihoo::protocol::messages::LogoutReq::internal_default_instance();
}
inline ::qihoo::protocol::messages::LogoutReq* Request::mutable_logout() {
  set_has_logout();
  if (logout_ == NULL) {
    logout_ = new ::qihoo::protocol::messages::LogoutReq;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.logout)
  return logout_;
}
inline ::qihoo::protocol::messages::LogoutReq* Request::release_logout() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Request.logout)
  clear_has_logout();
  ::qihoo::protocol::messages::LogoutReq* temp = logout_;
  logout_ = NULL;
  return temp;
}
inline void Request::set_allocated_logout(::qihoo::protocol::messages::LogoutReq* logout) {
  delete logout_;
  logout_ = logout;
  if (logout) {
    set_has_logout();
  } else {
    clear_has_logout();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.logout)
}

// optional .qihoo.protocol.messages.InitLoginReq init_login_req = 9;
inline bool Request::has_init_login_req() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_init_login_req() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_init_login_req() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_init_login_req() {
  if (init_login_req_ != NULL) init_login_req_->::qihoo::protocol::messages::InitLoginReq::Clear();
  clear_has_init_login_req();
}
inline const ::qihoo::protocol::messages::InitLoginReq& Request::init_login_req() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.init_login_req)
  return init_login_req_ != NULL ? *init_login_req_
                         : *::qihoo::protocol::messages::InitLoginReq::internal_default_instance();
}
inline ::qihoo::protocol::messages::InitLoginReq* Request::mutable_init_login_req() {
  set_has_init_login_req();
  if (init_login_req_ == NULL) {
    init_login_req_ = new ::qihoo::protocol::messages::InitLoginReq;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.init_login_req)
  return init_login_req_;
}
inline ::qihoo::protocol::messages::InitLoginReq* Request::release_init_login_req() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Request.init_login_req)
  clear_has_init_login_req();
  ::qihoo::protocol::messages::InitLoginReq* temp = init_login_req_;
  init_login_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_init_login_req(::qihoo::protocol::messages::InitLoginReq* init_login_req) {
  delete init_login_req_;
  init_login_req_ = init_login_req;
  if (init_login_req) {
    set_has_init_login_req();
  } else {
    clear_has_init_login_req();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.init_login_req)
}

// optional .qihoo.protocol.messages.Service_Req service_req = 11;
inline bool Request::has_service_req() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_service_req() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_service_req() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_service_req() {
  if (service_req_ != NULL) service_req_->::qihoo::protocol::messages::Service_Req::Clear();
  clear_has_service_req();
}
inline const ::qihoo::protocol::messages::Service_Req& Request::service_req() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.service_req)
  return service_req_ != NULL ? *service_req_
                         : *::qihoo::protocol::messages::Service_Req::internal_default_instance();
}
inline ::qihoo::protocol::messages::Service_Req* Request::mutable_service_req() {
  set_has_service_req();
  if (service_req_ == NULL) {
    service_req_ = new ::qihoo::protocol::messages::Service_Req;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.service_req)
  return service_req_;
}
inline ::qihoo::protocol::messages::Service_Req* Request::release_service_req() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Request.service_req)
  clear_has_service_req();
  ::qihoo::protocol::messages::Service_Req* temp = service_req_;
  service_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_service_req(::qihoo::protocol::messages::Service_Req* service_req) {
  delete service_req_;
  service_req_ = service_req;
  if (service_req) {
    set_has_service_req();
  } else {
    clear_has_service_req();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.service_req)
}

// optional .qihoo.protocol.messages.Ex1QueryUserStatusReq e1_query_user = 12;
inline bool Request::has_e1_query_user() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_e1_query_user() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_e1_query_user() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_e1_query_user() {
  if (e1_query_user_ != NULL) e1_query_user_->::qihoo::protocol::messages::Ex1QueryUserStatusReq::Clear();
  clear_has_e1_query_user();
}
inline const ::qihoo::protocol::messages::Ex1QueryUserStatusReq& Request::e1_query_user() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.e1_query_user)
  return e1_query_user_ != NULL ? *e1_query_user_
                         : *::qihoo::protocol::messages::Ex1QueryUserStatusReq::internal_default_instance();
}
inline ::qihoo::protocol::messages::Ex1QueryUserStatusReq* Request::mutable_e1_query_user() {
  set_has_e1_query_user();
  if (e1_query_user_ == NULL) {
    e1_query_user_ = new ::qihoo::protocol::messages::Ex1QueryUserStatusReq;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.e1_query_user)
  return e1_query_user_;
}
inline ::qihoo::protocol::messages::Ex1QueryUserStatusReq* Request::release_e1_query_user() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Request.e1_query_user)
  clear_has_e1_query_user();
  ::qihoo::protocol::messages::Ex1QueryUserStatusReq* temp = e1_query_user_;
  e1_query_user_ = NULL;
  return temp;
}
inline void Request::set_allocated_e1_query_user(::qihoo::protocol::messages::Ex1QueryUserStatusReq* e1_query_user) {
  delete e1_query_user_;
  e1_query_user_ = e1_query_user;
  if (e1_query_user) {
    set_has_e1_query_user();
  } else {
    clear_has_e1_query_user();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.e1_query_user)
}

// optional .qihoo.protocol.messages.GetMultiInfosReq get_multi_infos = 100;
inline bool Request::has_get_multi_infos() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request::set_has_get_multi_infos() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request::clear_has_get_multi_infos() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request::clear_get_multi_infos() {
  if (get_multi_infos_ != NULL) get_multi_infos_->::qihoo::protocol::messages::GetMultiInfosReq::Clear();
  clear_has_get_multi_infos();
}
inline const ::qihoo::protocol::messages::GetMultiInfosReq& Request::get_multi_infos() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.get_multi_infos)
  return get_multi_infos_ != NULL ? *get_multi_infos_
                         : *::qihoo::protocol::messages::GetMultiInfosReq::internal_default_instance();
}
inline ::qihoo::protocol::messages::GetMultiInfosReq* Request::mutable_get_multi_infos() {
  set_has_get_multi_infos();
  if (get_multi_infos_ == NULL) {
    get_multi_infos_ = new ::qihoo::protocol::messages::GetMultiInfosReq;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.get_multi_infos)
  return get_multi_infos_;
}
inline ::qihoo::protocol::messages::GetMultiInfosReq* Request::release_get_multi_infos() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Request.get_multi_infos)
  clear_has_get_multi_infos();
  ::qihoo::protocol::messages::GetMultiInfosReq* temp = get_multi_infos_;
  get_multi_infos_ = NULL;
  return temp;
}
inline void Request::set_allocated_get_multi_infos(::qihoo::protocol::messages::GetMultiInfosReq* get_multi_infos) {
  delete get_multi_infos_;
  get_multi_infos_ = get_multi_infos;
  if (get_multi_infos) {
    set_has_get_multi_infos();
  } else {
    clear_has_get_multi_infos();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.get_multi_infos)
}

// -------------------------------------------------------------------

// Response

// optional .qihoo.protocol.messages.Error error = 1;
inline bool Response::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_error() {
  if (error_ != NULL) error_->::qihoo::protocol::messages::Error::Clear();
  clear_has_error();
}
inline const ::qihoo::protocol::messages::Error& Response::error() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.error)
  return error_ != NULL ? *error_
                         : *::qihoo::protocol::messages::Error::internal_default_instance();
}
inline ::qihoo::protocol::messages::Error* Response::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    error_ = new ::qihoo::protocol::messages::Error;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.error)
  return error_;
}
inline ::qihoo::protocol::messages::Error* Response::release_error() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Response.error)
  clear_has_error();
  ::qihoo::protocol::messages::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void Response::set_allocated_error(::qihoo::protocol::messages::Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.error)
}

// optional .qihoo.protocol.messages.LoginResp login = 3;
inline bool Response::has_login() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_login() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_login() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_login() {
  if (login_ != NULL) login_->::qihoo::protocol::messages::LoginResp::Clear();
  clear_has_login();
}
inline const ::qihoo::protocol::messages::LoginResp& Response::login() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.login)
  return login_ != NULL ? *login_
                         : *::qihoo::protocol::messages::LoginResp::internal_default_instance();
}
inline ::qihoo::protocol::messages::LoginResp* Response::mutable_login() {
  set_has_login();
  if (login_ == NULL) {
    login_ = new ::qihoo::protocol::messages::LoginResp;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.login)
  return login_;
}
inline ::qihoo::protocol::messages::LoginResp* Response::release_login() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Response.login)
  clear_has_login();
  ::qihoo::protocol::messages::LoginResp* temp = login_;
  login_ = NULL;
  return temp;
}
inline void Response::set_allocated_login(::qihoo::protocol::messages::LoginResp* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.login)
}

// optional .qihoo.protocol.messages.ChatResp chat = 4;
inline bool Response::has_chat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_chat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_chat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_chat() {
  if (chat_ != NULL) chat_->::qihoo::protocol::messages::ChatResp::Clear();
  clear_has_chat();
}
inline const ::qihoo::protocol::messages::ChatResp& Response::chat() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.chat)
  return chat_ != NULL ? *chat_
                         : *::qihoo::protocol::messages::ChatResp::internal_default_instance();
}
inline ::qihoo::protocol::messages::ChatResp* Response::mutable_chat() {
  set_has_chat();
  if (chat_ == NULL) {
    chat_ = new ::qihoo::protocol::messages::ChatResp;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.chat)
  return chat_;
}
inline ::qihoo::protocol::messages::ChatResp* Response::release_chat() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Response.chat)
  clear_has_chat();
  ::qihoo::protocol::messages::ChatResp* temp = chat_;
  chat_ = NULL;
  return temp;
}
inline void Response::set_allocated_chat(::qihoo::protocol::messages::ChatResp* chat) {
  delete chat_;
  chat_ = chat;
  if (chat) {
    set_has_chat();
  } else {
    clear_has_chat();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.chat)
}

// optional .qihoo.protocol.messages.GetInfoResp get_info = 6;
inline bool Response::has_get_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_get_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_get_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_get_info() {
  if (get_info_ != NULL) get_info_->::qihoo::protocol::messages::GetInfoResp::Clear();
  clear_has_get_info();
}
inline const ::qihoo::protocol::messages::GetInfoResp& Response::get_info() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.get_info)
  return get_info_ != NULL ? *get_info_
                         : *::qihoo::protocol::messages::GetInfoResp::internal_default_instance();
}
inline ::qihoo::protocol::messages::GetInfoResp* Response::mutable_get_info() {
  set_has_get_info();
  if (get_info_ == NULL) {
    get_info_ = new ::qihoo::protocol::messages::GetInfoResp;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.get_info)
  return get_info_;
}
inline ::qihoo::protocol::messages::GetInfoResp* Response::release_get_info() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Response.get_info)
  clear_has_get_info();
  ::qihoo::protocol::messages::GetInfoResp* temp = get_info_;
  get_info_ = NULL;
  return temp;
}
inline void Response::set_allocated_get_info(::qihoo::protocol::messages::GetInfoResp* get_info) {
  delete get_info_;
  get_info_ = get_info;
  if (get_info) {
    set_has_get_info();
  } else {
    clear_has_get_info();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.get_info)
}

// optional .qihoo.protocol.messages.LogoutResp logout = 7;
inline bool Response::has_logout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_logout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_logout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_logout() {
  if (logout_ != NULL) logout_->::qihoo::protocol::messages::LogoutResp::Clear();
  clear_has_logout();
}
inline const ::qihoo::protocol::messages::LogoutResp& Response::logout() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.logout)
  return logout_ != NULL ? *logout_
                         : *::qihoo::protocol::messages::LogoutResp::internal_default_instance();
}
inline ::qihoo::protocol::messages::LogoutResp* Response::mutable_logout() {
  set_has_logout();
  if (logout_ == NULL) {
    logout_ = new ::qihoo::protocol::messages::LogoutResp;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.logout)
  return logout_;
}
inline ::qihoo::protocol::messages::LogoutResp* Response::release_logout() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Response.logout)
  clear_has_logout();
  ::qihoo::protocol::messages::LogoutResp* temp = logout_;
  logout_ = NULL;
  return temp;
}
inline void Response::set_allocated_logout(::qihoo::protocol::messages::LogoutResp* logout) {
  delete logout_;
  logout_ = logout;
  if (logout) {
    set_has_logout();
  } else {
    clear_has_logout();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.logout)
}

// optional .qihoo.protocol.messages.InitLoginResp init_login_resp = 10;
inline bool Response::has_init_login_resp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_init_login_resp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_init_login_resp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_init_login_resp() {
  if (init_login_resp_ != NULL) init_login_resp_->::qihoo::protocol::messages::InitLoginResp::Clear();
  clear_has_init_login_resp();
}
inline const ::qihoo::protocol::messages::InitLoginResp& Response::init_login_resp() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.init_login_resp)
  return init_login_resp_ != NULL ? *init_login_resp_
                         : *::qihoo::protocol::messages::InitLoginResp::internal_default_instance();
}
inline ::qihoo::protocol::messages::InitLoginResp* Response::mutable_init_login_resp() {
  set_has_init_login_resp();
  if (init_login_resp_ == NULL) {
    init_login_resp_ = new ::qihoo::protocol::messages::InitLoginResp;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.init_login_resp)
  return init_login_resp_;
}
inline ::qihoo::protocol::messages::InitLoginResp* Response::release_init_login_resp() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Response.init_login_resp)
  clear_has_init_login_resp();
  ::qihoo::protocol::messages::InitLoginResp* temp = init_login_resp_;
  init_login_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_init_login_resp(::qihoo::protocol::messages::InitLoginResp* init_login_resp) {
  delete init_login_resp_;
  init_login_resp_ = init_login_resp;
  if (init_login_resp) {
    set_has_init_login_resp();
  } else {
    clear_has_init_login_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.init_login_resp)
}

// optional .qihoo.protocol.messages.Service_Resp service_resp = 12;
inline bool Response::has_service_resp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_service_resp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_service_resp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_service_resp() {
  if (service_resp_ != NULL) service_resp_->::qihoo::protocol::messages::Service_Resp::Clear();
  clear_has_service_resp();
}
inline const ::qihoo::protocol::messages::Service_Resp& Response::service_resp() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.service_resp)
  return service_resp_ != NULL ? *service_resp_
                         : *::qihoo::protocol::messages::Service_Resp::internal_default_instance();
}
inline ::qihoo::protocol::messages::Service_Resp* Response::mutable_service_resp() {
  set_has_service_resp();
  if (service_resp_ == NULL) {
    service_resp_ = new ::qihoo::protocol::messages::Service_Resp;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.service_resp)
  return service_resp_;
}
inline ::qihoo::protocol::messages::Service_Resp* Response::release_service_resp() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Response.service_resp)
  clear_has_service_resp();
  ::qihoo::protocol::messages::Service_Resp* temp = service_resp_;
  service_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_service_resp(::qihoo::protocol::messages::Service_Resp* service_resp) {
  delete service_resp_;
  service_resp_ = service_resp;
  if (service_resp) {
    set_has_service_resp();
  } else {
    clear_has_service_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.service_resp)
}

// optional .qihoo.protocol.messages.Ex1QueryUserStatusResp e1_query_user = 13;
inline bool Response::has_e1_query_user() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Response::set_has_e1_query_user() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Response::clear_has_e1_query_user() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Response::clear_e1_query_user() {
  if (e1_query_user_ != NULL) e1_query_user_->::qihoo::protocol::messages::Ex1QueryUserStatusResp::Clear();
  clear_has_e1_query_user();
}
inline const ::qihoo::protocol::messages::Ex1QueryUserStatusResp& Response::e1_query_user() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.e1_query_user)
  return e1_query_user_ != NULL ? *e1_query_user_
                         : *::qihoo::protocol::messages::Ex1QueryUserStatusResp::internal_default_instance();
}
inline ::qihoo::protocol::messages::Ex1QueryUserStatusResp* Response::mutable_e1_query_user() {
  set_has_e1_query_user();
  if (e1_query_user_ == NULL) {
    e1_query_user_ = new ::qihoo::protocol::messages::Ex1QueryUserStatusResp;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.e1_query_user)
  return e1_query_user_;
}
inline ::qihoo::protocol::messages::Ex1QueryUserStatusResp* Response::release_e1_query_user() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Response.e1_query_user)
  clear_has_e1_query_user();
  ::qihoo::protocol::messages::Ex1QueryUserStatusResp* temp = e1_query_user_;
  e1_query_user_ = NULL;
  return temp;
}
inline void Response::set_allocated_e1_query_user(::qihoo::protocol::messages::Ex1QueryUserStatusResp* e1_query_user) {
  delete e1_query_user_;
  e1_query_user_ = e1_query_user;
  if (e1_query_user) {
    set_has_e1_query_user();
  } else {
    clear_has_e1_query_user();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.e1_query_user)
}

// optional .qihoo.protocol.messages.GetMultiInfosResp get_multi_infos = 100;
inline bool Response::has_get_multi_infos() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Response::set_has_get_multi_infos() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Response::clear_has_get_multi_infos() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Response::clear_get_multi_infos() {
  if (get_multi_infos_ != NULL) get_multi_infos_->::qihoo::protocol::messages::GetMultiInfosResp::Clear();
  clear_has_get_multi_infos();
}
inline const ::qihoo::protocol::messages::GetMultiInfosResp& Response::get_multi_infos() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.get_multi_infos)
  return get_multi_infos_ != NULL ? *get_multi_infos_
                         : *::qihoo::protocol::messages::GetMultiInfosResp::internal_default_instance();
}
inline ::qihoo::protocol::messages::GetMultiInfosResp* Response::mutable_get_multi_infos() {
  set_has_get_multi_infos();
  if (get_multi_infos_ == NULL) {
    get_multi_infos_ = new ::qihoo::protocol::messages::GetMultiInfosResp;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.get_multi_infos)
  return get_multi_infos_;
}
inline ::qihoo::protocol::messages::GetMultiInfosResp* Response::release_get_multi_infos() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Response.get_multi_infos)
  clear_has_get_multi_infos();
  ::qihoo::protocol::messages::GetMultiInfosResp* temp = get_multi_infos_;
  get_multi_infos_ = NULL;
  return temp;
}
inline void Response::set_allocated_get_multi_infos(::qihoo::protocol::messages::GetMultiInfosResp* get_multi_infos) {
  delete get_multi_infos_;
  get_multi_infos_ = get_multi_infos;
  if (get_multi_infos) {
    set_has_get_multi_infos();
  } else {
    clear_has_get_multi_infos();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.get_multi_infos)
}

// -------------------------------------------------------------------

// NewMessageNotify

// required string info_type = 1;
inline bool NewMessageNotify::has_info_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewMessageNotify::set_has_info_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewMessageNotify::clear_has_info_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewMessageNotify::clear_info_type() {
  info_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_info_type();
}
inline const ::std::string& NewMessageNotify::info_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.NewMessageNotify.info_type)
  return info_type_.GetNoArena();
}
inline void NewMessageNotify::set_info_type(const ::std::string& value) {
  set_has_info_type();
  info_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.NewMessageNotify.info_type)
}
#if LANG_CXX11
inline void NewMessageNotify::set_info_type(::std::string&& value) {
  set_has_info_type();
  info_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.NewMessageNotify.info_type)
}
#endif
inline void NewMessageNotify::set_info_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_info_type();
  info_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.NewMessageNotify.info_type)
}
inline void NewMessageNotify::set_info_type(const char* value, size_t size) {
  set_has_info_type();
  info_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.NewMessageNotify.info_type)
}
inline ::std::string* NewMessageNotify::mutable_info_type() {
  set_has_info_type();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.NewMessageNotify.info_type)
  return info_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewMessageNotify::release_info_type() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.NewMessageNotify.info_type)
  clear_has_info_type();
  return info_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewMessageNotify::set_allocated_info_type(::std::string* info_type) {
  if (info_type != NULL) {
    set_has_info_type();
  } else {
    clear_has_info_type();
  }
  info_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info_type);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.NewMessageNotify.info_type)
}

// optional bytes info_content = 2;
inline bool NewMessageNotify::has_info_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewMessageNotify::set_has_info_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewMessageNotify::clear_has_info_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewMessageNotify::clear_info_content() {
  info_content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_info_content();
}
inline const ::std::string& NewMessageNotify::info_content() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.NewMessageNotify.info_content)
  return info_content_.GetNoArena();
}
inline void NewMessageNotify::set_info_content(const ::std::string& value) {
  set_has_info_content();
  info_content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.NewMessageNotify.info_content)
}
#if LANG_CXX11
inline void NewMessageNotify::set_info_content(::std::string&& value) {
  set_has_info_content();
  info_content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.NewMessageNotify.info_content)
}
#endif
inline void NewMessageNotify::set_info_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_info_content();
  info_content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.NewMessageNotify.info_content)
}
inline void NewMessageNotify::set_info_content(const void* value, size_t size) {
  set_has_info_content();
  info_content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.NewMessageNotify.info_content)
}
inline ::std::string* NewMessageNotify::mutable_info_content() {
  set_has_info_content();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.NewMessageNotify.info_content)
  return info_content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewMessageNotify::release_info_content() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.NewMessageNotify.info_content)
  clear_has_info_content();
  return info_content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewMessageNotify::set_allocated_info_content(::std::string* info_content) {
  if (info_content != NULL) {
    set_has_info_content();
  } else {
    clear_has_info_content();
  }
  info_content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info_content);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.NewMessageNotify.info_content)
}

// optional int64 info_id = 3;
inline bool NewMessageNotify::has_info_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewMessageNotify::set_has_info_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewMessageNotify::clear_has_info_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewMessageNotify::clear_info_id() {
  info_id_ = GOOGLE_LONGLONG(0);
  clear_has_info_id();
}
inline ::google::protobuf::int64 NewMessageNotify::info_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.NewMessageNotify.info_id)
  return info_id_;
}
inline void NewMessageNotify::set_info_id(::google::protobuf::int64 value) {
  set_has_info_id();
  info_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.NewMessageNotify.info_id)
}

// optional uint32 query_after_seconds = 4;
inline bool NewMessageNotify::has_query_after_seconds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewMessageNotify::set_has_query_after_seconds() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewMessageNotify::clear_has_query_after_seconds() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewMessageNotify::clear_query_after_seconds() {
  query_after_seconds_ = 0u;
  clear_has_query_after_seconds();
}
inline ::google::protobuf::uint32 NewMessageNotify::query_after_seconds() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.NewMessageNotify.query_after_seconds)
  return query_after_seconds_;
}
inline void NewMessageNotify::set_query_after_seconds(::google::protobuf::uint32 value) {
  set_has_query_after_seconds();
  query_after_seconds_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.NewMessageNotify.query_after_seconds)
}

// -------------------------------------------------------------------

// ReLoginNotify

// optional string new_ip = 1;
inline bool ReLoginNotify::has_new_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReLoginNotify::set_has_new_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReLoginNotify::clear_has_new_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReLoginNotify::clear_new_ip() {
  new_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_new_ip();
}
inline const ::std::string& ReLoginNotify::new_ip() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ReLoginNotify.new_ip)
  return new_ip_.GetNoArena();
}
inline void ReLoginNotify::set_new_ip(const ::std::string& value) {
  set_has_new_ip();
  new_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ReLoginNotify.new_ip)
}
#if LANG_CXX11
inline void ReLoginNotify::set_new_ip(::std::string&& value) {
  set_has_new_ip();
  new_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.ReLoginNotify.new_ip)
}
#endif
inline void ReLoginNotify::set_new_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_new_ip();
  new_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ReLoginNotify.new_ip)
}
inline void ReLoginNotify::set_new_ip(const char* value, size_t size) {
  set_has_new_ip();
  new_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ReLoginNotify.new_ip)
}
inline ::std::string* ReLoginNotify::mutable_new_ip() {
  set_has_new_ip();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ReLoginNotify.new_ip)
  return new_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReLoginNotify::release_new_ip() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.ReLoginNotify.new_ip)
  clear_has_new_ip();
  return new_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReLoginNotify::set_allocated_new_ip(::std::string* new_ip) {
  if (new_ip != NULL) {
    set_has_new_ip();
  } else {
    clear_has_new_ip();
  }
  new_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_ip);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.ReLoginNotify.new_ip)
}

// -------------------------------------------------------------------

// ReConnectNotify

// optional string ip = 1;
inline bool ReConnectNotify::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReConnectNotify::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReConnectNotify::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReConnectNotify::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& ReConnectNotify::ip() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ReConnectNotify.ip)
  return ip_.GetNoArena();
}
inline void ReConnectNotify::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ReConnectNotify.ip)
}
#if LANG_CXX11
inline void ReConnectNotify::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.ReConnectNotify.ip)
}
#endif
inline void ReConnectNotify::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ReConnectNotify.ip)
}
inline void ReConnectNotify::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ReConnectNotify.ip)
}
inline ::std::string* ReConnectNotify::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ReConnectNotify.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReConnectNotify::release_ip() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.ReConnectNotify.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReConnectNotify::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.ReConnectNotify.ip)
}

// optional uint32 port = 2;
inline bool ReConnectNotify::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReConnectNotify::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReConnectNotify::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReConnectNotify::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 ReConnectNotify::port() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ReConnectNotify.port)
  return port_;
}
inline void ReConnectNotify::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ReConnectNotify.port)
}

// repeated string more_ips = 3;
inline int ReConnectNotify::more_ips_size() const {
  return more_ips_.size();
}
inline void ReConnectNotify::clear_more_ips() {
  more_ips_.Clear();
}
inline const ::std::string& ReConnectNotify::more_ips(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ReConnectNotify.more_ips)
  return more_ips_.Get(index);
}
inline ::std::string* ReConnectNotify::mutable_more_ips(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ReConnectNotify.more_ips)
  return more_ips_.Mutable(index);
}
inline void ReConnectNotify::set_more_ips(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ReConnectNotify.more_ips)
  more_ips_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ReConnectNotify::set_more_ips(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ReConnectNotify.more_ips)
  more_ips_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ReConnectNotify::set_more_ips(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  more_ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ReConnectNotify.more_ips)
}
inline void ReConnectNotify::set_more_ips(int index, const char* value, size_t size) {
  more_ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ReConnectNotify.more_ips)
}
inline ::std::string* ReConnectNotify::add_more_ips() {
  // @@protoc_insertion_point(field_add_mutable:qihoo.protocol.messages.ReConnectNotify.more_ips)
  return more_ips_.Add();
}
inline void ReConnectNotify::add_more_ips(const ::std::string& value) {
  more_ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.ReConnectNotify.more_ips)
}
#if LANG_CXX11
inline void ReConnectNotify::add_more_ips(::std::string&& value) {
  more_ips_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.ReConnectNotify.more_ips)
}
#endif
inline void ReConnectNotify::add_more_ips(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  more_ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:qihoo.protocol.messages.ReConnectNotify.more_ips)
}
inline void ReConnectNotify::add_more_ips(const char* value, size_t size) {
  more_ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:qihoo.protocol.messages.ReConnectNotify.more_ips)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReConnectNotify::more_ips() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.ReConnectNotify.more_ips)
  return more_ips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReConnectNotify::mutable_more_ips() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.ReConnectNotify.more_ips)
  return &more_ips_;
}

// -------------------------------------------------------------------

// Notify

// optional .qihoo.protocol.messages.NewMessageNotify newinfo_ntf = 1;
inline bool Notify::has_newinfo_ntf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Notify::set_has_newinfo_ntf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Notify::clear_has_newinfo_ntf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Notify::clear_newinfo_ntf() {
  if (newinfo_ntf_ != NULL) newinfo_ntf_->::qihoo::protocol::messages::NewMessageNotify::Clear();
  clear_has_newinfo_ntf();
}
inline const ::qihoo::protocol::messages::NewMessageNotify& Notify::newinfo_ntf() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Notify.newinfo_ntf)
  return newinfo_ntf_ != NULL ? *newinfo_ntf_
                         : *::qihoo::protocol::messages::NewMessageNotify::internal_default_instance();
}
inline ::qihoo::protocol::messages::NewMessageNotify* Notify::mutable_newinfo_ntf() {
  set_has_newinfo_ntf();
  if (newinfo_ntf_ == NULL) {
    newinfo_ntf_ = new ::qihoo::protocol::messages::NewMessageNotify;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Notify.newinfo_ntf)
  return newinfo_ntf_;
}
inline ::qihoo::protocol::messages::NewMessageNotify* Notify::release_newinfo_ntf() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Notify.newinfo_ntf)
  clear_has_newinfo_ntf();
  ::qihoo::protocol::messages::NewMessageNotify* temp = newinfo_ntf_;
  newinfo_ntf_ = NULL;
  return temp;
}
inline void Notify::set_allocated_newinfo_ntf(::qihoo::protocol::messages::NewMessageNotify* newinfo_ntf) {
  delete newinfo_ntf_;
  newinfo_ntf_ = newinfo_ntf;
  if (newinfo_ntf) {
    set_has_newinfo_ntf();
  } else {
    clear_has_newinfo_ntf();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Notify.newinfo_ntf)
}

// optional .qihoo.protocol.messages.ReLoginNotify relogin_ntf = 2;
inline bool Notify::has_relogin_ntf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Notify::set_has_relogin_ntf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Notify::clear_has_relogin_ntf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Notify::clear_relogin_ntf() {
  if (relogin_ntf_ != NULL) relogin_ntf_->::qihoo::protocol::messages::ReLoginNotify::Clear();
  clear_has_relogin_ntf();
}
inline const ::qihoo::protocol::messages::ReLoginNotify& Notify::relogin_ntf() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Notify.relogin_ntf)
  return relogin_ntf_ != NULL ? *relogin_ntf_
                         : *::qihoo::protocol::messages::ReLoginNotify::internal_default_instance();
}
inline ::qihoo::protocol::messages::ReLoginNotify* Notify::mutable_relogin_ntf() {
  set_has_relogin_ntf();
  if (relogin_ntf_ == NULL) {
    relogin_ntf_ = new ::qihoo::protocol::messages::ReLoginNotify;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Notify.relogin_ntf)
  return relogin_ntf_;
}
inline ::qihoo::protocol::messages::ReLoginNotify* Notify::release_relogin_ntf() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Notify.relogin_ntf)
  clear_has_relogin_ntf();
  ::qihoo::protocol::messages::ReLoginNotify* temp = relogin_ntf_;
  relogin_ntf_ = NULL;
  return temp;
}
inline void Notify::set_allocated_relogin_ntf(::qihoo::protocol::messages::ReLoginNotify* relogin_ntf) {
  delete relogin_ntf_;
  relogin_ntf_ = relogin_ntf;
  if (relogin_ntf) {
    set_has_relogin_ntf();
  } else {
    clear_has_relogin_ntf();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Notify.relogin_ntf)
}

// optional .qihoo.protocol.messages.ReConnectNotify reconnect_ntf = 3;
inline bool Notify::has_reconnect_ntf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Notify::set_has_reconnect_ntf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Notify::clear_has_reconnect_ntf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Notify::clear_reconnect_ntf() {
  if (reconnect_ntf_ != NULL) reconnect_ntf_->::qihoo::protocol::messages::ReConnectNotify::Clear();
  clear_has_reconnect_ntf();
}
inline const ::qihoo::protocol::messages::ReConnectNotify& Notify::reconnect_ntf() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Notify.reconnect_ntf)
  return reconnect_ntf_ != NULL ? *reconnect_ntf_
                         : *::qihoo::protocol::messages::ReConnectNotify::internal_default_instance();
}
inline ::qihoo::protocol::messages::ReConnectNotify* Notify::mutable_reconnect_ntf() {
  set_has_reconnect_ntf();
  if (reconnect_ntf_ == NULL) {
    reconnect_ntf_ = new ::qihoo::protocol::messages::ReConnectNotify;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Notify.reconnect_ntf)
  return reconnect_ntf_;
}
inline ::qihoo::protocol::messages::ReConnectNotify* Notify::release_reconnect_ntf() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Notify.reconnect_ntf)
  clear_has_reconnect_ntf();
  ::qihoo::protocol::messages::ReConnectNotify* temp = reconnect_ntf_;
  reconnect_ntf_ = NULL;
  return temp;
}
inline void Notify::set_allocated_reconnect_ntf(::qihoo::protocol::messages::ReConnectNotify* reconnect_ntf) {
  delete reconnect_ntf_;
  reconnect_ntf_ = reconnect_ntf;
  if (reconnect_ntf) {
    set_has_reconnect_ntf();
  } else {
    clear_has_reconnect_ntf();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Notify.reconnect_ntf)
}

// -------------------------------------------------------------------

// Ack

// required uint32 result = 1;
inline bool Ack::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ack::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ack::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ack::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 Ack::result() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Ack.result)
  return result_;
}
inline void Ack::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Ack.result)
}

// -------------------------------------------------------------------

// RouteInfo

// required bytes username = 1;
inline bool RouteInfo::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RouteInfo::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RouteInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RouteInfo::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& RouteInfo::username() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RouteInfo.username)
  return username_.GetNoArena();
}
inline void RouteInfo::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RouteInfo.username)
}
#if LANG_CXX11
inline void RouteInfo::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.RouteInfo.username)
}
#endif
inline void RouteInfo::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RouteInfo.username)
}
inline void RouteInfo::set_username(const void* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RouteInfo.username)
}
inline ::std::string* RouteInfo::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RouteInfo.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteInfo::release_username() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.RouteInfo.username)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteInfo::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RouteInfo.username)
}

// required string msg_exchanger = 2;
inline bool RouteInfo::has_msg_exchanger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RouteInfo::set_has_msg_exchanger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RouteInfo::clear_has_msg_exchanger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RouteInfo::clear_msg_exchanger() {
  msg_exchanger_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg_exchanger();
}
inline const ::std::string& RouteInfo::msg_exchanger() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RouteInfo.msg_exchanger)
  return msg_exchanger_.GetNoArena();
}
inline void RouteInfo::set_msg_exchanger(const ::std::string& value) {
  set_has_msg_exchanger();
  msg_exchanger_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RouteInfo.msg_exchanger)
}
#if LANG_CXX11
inline void RouteInfo::set_msg_exchanger(::std::string&& value) {
  set_has_msg_exchanger();
  msg_exchanger_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.RouteInfo.msg_exchanger)
}
#endif
inline void RouteInfo::set_msg_exchanger(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_msg_exchanger();
  msg_exchanger_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RouteInfo.msg_exchanger)
}
inline void RouteInfo::set_msg_exchanger(const char* value, size_t size) {
  set_has_msg_exchanger();
  msg_exchanger_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RouteInfo.msg_exchanger)
}
inline ::std::string* RouteInfo::mutable_msg_exchanger() {
  set_has_msg_exchanger();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RouteInfo.msg_exchanger)
  return msg_exchanger_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteInfo::release_msg_exchanger() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.RouteInfo.msg_exchanger)
  clear_has_msg_exchanger();
  return msg_exchanger_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteInfo::set_allocated_msg_exchanger(::std::string* msg_exchanger) {
  if (msg_exchanger != NULL) {
    set_has_msg_exchanger();
  } else {
    clear_has_msg_exchanger();
  }
  msg_exchanger_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg_exchanger);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RouteInfo.msg_exchanger)
}

// required string msg_router = 3;
inline bool RouteInfo::has_msg_router() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RouteInfo::set_has_msg_router() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RouteInfo::clear_has_msg_router() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RouteInfo::clear_msg_router() {
  msg_router_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg_router();
}
inline const ::std::string& RouteInfo::msg_router() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RouteInfo.msg_router)
  return msg_router_.GetNoArena();
}
inline void RouteInfo::set_msg_router(const ::std::string& value) {
  set_has_msg_router();
  msg_router_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RouteInfo.msg_router)
}
#if LANG_CXX11
inline void RouteInfo::set_msg_router(::std::string&& value) {
  set_has_msg_router();
  msg_router_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.RouteInfo.msg_router)
}
#endif
inline void RouteInfo::set_msg_router(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_msg_router();
  msg_router_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RouteInfo.msg_router)
}
inline void RouteInfo::set_msg_router(const char* value, size_t size) {
  set_has_msg_router();
  msg_router_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RouteInfo.msg_router)
}
inline ::std::string* RouteInfo::mutable_msg_router() {
  set_has_msg_router();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RouteInfo.msg_router)
  return msg_router_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteInfo::release_msg_router() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.RouteInfo.msg_router)
  clear_has_msg_router();
  return msg_router_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteInfo::set_allocated_msg_router(::std::string* msg_router) {
  if (msg_router != NULL) {
    set_has_msg_router();
  } else {
    clear_has_msg_router();
  }
  msg_router_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg_router);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RouteInfo.msg_router)
}

// -------------------------------------------------------------------

// Proxy

// required string sender = 1;
inline bool Proxy::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proxy::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proxy::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proxy::clear_sender() {
  sender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sender();
}
inline const ::std::string& Proxy::sender() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Proxy.sender)
  return sender_.GetNoArena();
}
inline void Proxy::set_sender(const ::std::string& value) {
  set_has_sender();
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Proxy.sender)
}
#if LANG_CXX11
inline void Proxy::set_sender(::std::string&& value) {
  set_has_sender();
  sender_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.Proxy.sender)
}
#endif
inline void Proxy::set_sender(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sender();
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Proxy.sender)
}
inline void Proxy::set_sender(const char* value, size_t size) {
  set_has_sender();
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Proxy.sender)
}
inline ::std::string* Proxy::mutable_sender() {
  set_has_sender();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Proxy.sender)
  return sender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Proxy::release_sender() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Proxy.sender)
  clear_has_sender();
  return sender_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Proxy::set_allocated_sender(::std::string* sender) {
  if (sender != NULL) {
    set_has_sender();
  } else {
    clear_has_sender();
  }
  sender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sender);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Proxy.sender)
}

// repeated .qihoo.protocol.messages.RouteInfo receiver = 2;
inline int Proxy::receiver_size() const {
  return receiver_.size();
}
inline void Proxy::clear_receiver() {
  receiver_.Clear();
}
inline const ::qihoo::protocol::messages::RouteInfo& Proxy::receiver(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Proxy.receiver)
  return receiver_.Get(index);
}
inline ::qihoo::protocol::messages::RouteInfo* Proxy::mutable_receiver(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Proxy.receiver)
  return receiver_.Mutable(index);
}
inline ::qihoo::protocol::messages::RouteInfo* Proxy::add_receiver() {
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.Proxy.receiver)
  return receiver_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RouteInfo >*
Proxy::mutable_receiver() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.Proxy.receiver)
  return &receiver_;
}
inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RouteInfo >&
Proxy::receiver() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.Proxy.receiver)
  return receiver_;
}

// -------------------------------------------------------------------

// Message

// required uint32 msgid = 1;
inline bool Message::has_msgid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Message::set_has_msgid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Message::clear_has_msgid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Message::clear_msgid() {
  msgid_ = 0u;
  clear_has_msgid();
}
inline ::google::protobuf::uint32 Message::msgid() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.msgid)
  return msgid_;
}
inline void Message::set_msgid(::google::protobuf::uint32 value) {
  set_has_msgid();
  msgid_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.msgid)
}

// required uint64 sn = 2;
inline bool Message::has_sn() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message::set_has_sn() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message::clear_has_sn() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message::clear_sn() {
  sn_ = GOOGLE_ULONGLONG(0);
  clear_has_sn();
}
inline ::google::protobuf::uint64 Message::sn() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.sn)
  return sn_;
}
inline void Message::set_sn(::google::protobuf::uint64 value) {
  set_has_sn();
  sn_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.sn)
}

// optional string sender = 3;
inline bool Message::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_sender() {
  sender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sender();
}
inline const ::std::string& Message::sender() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.sender)
  return sender_.GetNoArena();
}
inline void Message::set_sender(const ::std::string& value) {
  set_has_sender();
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.sender)
}
#if LANG_CXX11
inline void Message::set_sender(::std::string&& value) {
  set_has_sender();
  sender_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.Message.sender)
}
#endif
inline void Message::set_sender(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sender();
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Message.sender)
}
inline void Message::set_sender(const char* value, size_t size) {
  set_has_sender();
  sender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Message.sender)
}
inline ::std::string* Message::mutable_sender() {
  set_has_sender();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.sender)
  return sender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_sender() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Message.sender)
  clear_has_sender();
  return sender_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_sender(::std::string* sender) {
  if (sender != NULL) {
    set_has_sender();
  } else {
    clear_has_sender();
  }
  sender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sender);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.sender)
}

// optional string receiver = 4;
inline bool Message::has_receiver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_receiver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_receiver() {
  receiver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_receiver();
}
inline const ::std::string& Message::receiver() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.receiver)
  return receiver_.GetNoArena();
}
inline void Message::set_receiver(const ::std::string& value) {
  set_has_receiver();
  receiver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.receiver)
}
#if LANG_CXX11
inline void Message::set_receiver(::std::string&& value) {
  set_has_receiver();
  receiver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.Message.receiver)
}
#endif
inline void Message::set_receiver(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_receiver();
  receiver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Message.receiver)
}
inline void Message::set_receiver(const char* value, size_t size) {
  set_has_receiver();
  receiver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Message.receiver)
}
inline ::std::string* Message::mutable_receiver() {
  set_has_receiver();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.receiver)
  return receiver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_receiver() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Message.receiver)
  clear_has_receiver();
  return receiver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_receiver(::std::string* receiver) {
  if (receiver != NULL) {
    set_has_receiver();
  } else {
    clear_has_receiver();
  }
  receiver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receiver);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.receiver)
}

// optional string receiver_type = 5;
inline bool Message::has_receiver_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_receiver_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_receiver_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_receiver_type() {
  receiver_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_receiver_type();
}
inline const ::std::string& Message::receiver_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.receiver_type)
  return receiver_type_.GetNoArena();
}
inline void Message::set_receiver_type(const ::std::string& value) {
  set_has_receiver_type();
  receiver_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.receiver_type)
}
#if LANG_CXX11
inline void Message::set_receiver_type(::std::string&& value) {
  set_has_receiver_type();
  receiver_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.Message.receiver_type)
}
#endif
inline void Message::set_receiver_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_receiver_type();
  receiver_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Message.receiver_type)
}
inline void Message::set_receiver_type(const char* value, size_t size) {
  set_has_receiver_type();
  receiver_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Message.receiver_type)
}
inline ::std::string* Message::mutable_receiver_type() {
  set_has_receiver_type();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.receiver_type)
  return receiver_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_receiver_type() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Message.receiver_type)
  clear_has_receiver_type();
  return receiver_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_receiver_type(::std::string* receiver_type) {
  if (receiver_type != NULL) {
    set_has_receiver_type();
  } else {
    clear_has_receiver_type();
  }
  receiver_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receiver_type);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.receiver_type)
}

// optional .qihoo.protocol.messages.Request req = 6;
inline bool Message::has_req() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_req() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_req() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_req() {
  if (req_ != NULL) req_->::qihoo::protocol::messages::Request::Clear();
  clear_has_req();
}
inline const ::qihoo::protocol::messages::Request& Message::req() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.req)
  return req_ != NULL ? *req_
                         : *::qihoo::protocol::messages::Request::internal_default_instance();
}
inline ::qihoo::protocol::messages::Request* Message::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    req_ = new ::qihoo::protocol::messages::Request;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.req)
  return req_;
}
inline ::qihoo::protocol::messages::Request* Message::release_req() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Message.req)
  clear_has_req();
  ::qihoo::protocol::messages::Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void Message::set_allocated_req(::qihoo::protocol::messages::Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.req)
}

// optional .qihoo.protocol.messages.Response resp = 7;
inline bool Message::has_resp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message::set_has_resp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message::clear_has_resp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message::clear_resp() {
  if (resp_ != NULL) resp_->::qihoo::protocol::messages::Response::Clear();
  clear_has_resp();
}
inline const ::qihoo::protocol::messages::Response& Message::resp() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.resp)
  return resp_ != NULL ? *resp_
                         : *::qihoo::protocol::messages::Response::internal_default_instance();
}
inline ::qihoo::protocol::messages::Response* Message::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    resp_ = new ::qihoo::protocol::messages::Response;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.resp)
  return resp_;
}
inline ::qihoo::protocol::messages::Response* Message::release_resp() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Message.resp)
  clear_has_resp();
  ::qihoo::protocol::messages::Response* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void Message::set_allocated_resp(::qihoo::protocol::messages::Response* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    set_has_resp();
  } else {
    clear_has_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.resp)
}

// optional .qihoo.protocol.messages.Notify notify = 8;
inline bool Message::has_notify() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message::set_has_notify() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message::clear_has_notify() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message::clear_notify() {
  if (notify_ != NULL) notify_->::qihoo::protocol::messages::Notify::Clear();
  clear_has_notify();
}
inline const ::qihoo::protocol::messages::Notify& Message::notify() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.notify)
  return notify_ != NULL ? *notify_
                         : *::qihoo::protocol::messages::Notify::internal_default_instance();
}
inline ::qihoo::protocol::messages::Notify* Message::mutable_notify() {
  set_has_notify();
  if (notify_ == NULL) {
    notify_ = new ::qihoo::protocol::messages::Notify;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.notify)
  return notify_;
}
inline ::qihoo::protocol::messages::Notify* Message::release_notify() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Message.notify)
  clear_has_notify();
  ::qihoo::protocol::messages::Notify* temp = notify_;
  notify_ = NULL;
  return temp;
}
inline void Message::set_allocated_notify(::qihoo::protocol::messages::Notify* notify) {
  delete notify_;
  notify_ = notify;
  if (notify) {
    set_has_notify();
  } else {
    clear_has_notify();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.notify)
}

// optional .qihoo.protocol.messages.Ack ack = 9;
inline bool Message::has_ack() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Message::set_has_ack() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Message::clear_has_ack() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Message::clear_ack() {
  if (ack_ != NULL) ack_->::qihoo::protocol::messages::Ack::Clear();
  clear_has_ack();
}
inline const ::qihoo::protocol::messages::Ack& Message::ack() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.ack)
  return ack_ != NULL ? *ack_
                         : *::qihoo::protocol::messages::Ack::internal_default_instance();
}
inline ::qihoo::protocol::messages::Ack* Message::mutable_ack() {
  set_has_ack();
  if (ack_ == NULL) {
    ack_ = new ::qihoo::protocol::messages::Ack;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.ack)
  return ack_;
}
inline ::qihoo::protocol::messages::Ack* Message::release_ack() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Message.ack)
  clear_has_ack();
  ::qihoo::protocol::messages::Ack* temp = ack_;
  ack_ = NULL;
  return temp;
}
inline void Message::set_allocated_ack(::qihoo::protocol::messages::Ack* ack) {
  delete ack_;
  ack_ = ack;
  if (ack) {
    set_has_ack();
  } else {
    clear_has_ack();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.ack)
}

// optional .qihoo.protocol.messages.Proxy proxy_mesg = 10;
inline bool Message::has_proxy_mesg() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message::set_has_proxy_mesg() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message::clear_has_proxy_mesg() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message::clear_proxy_mesg() {
  if (proxy_mesg_ != NULL) proxy_mesg_->::qihoo::protocol::messages::Proxy::Clear();
  clear_has_proxy_mesg();
}
inline const ::qihoo::protocol::messages::Proxy& Message::proxy_mesg() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.proxy_mesg)
  return proxy_mesg_ != NULL ? *proxy_mesg_
                         : *::qihoo::protocol::messages::Proxy::internal_default_instance();
}
inline ::qihoo::protocol::messages::Proxy* Message::mutable_proxy_mesg() {
  set_has_proxy_mesg();
  if (proxy_mesg_ == NULL) {
    proxy_mesg_ = new ::qihoo::protocol::messages::Proxy;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.proxy_mesg)
  return proxy_mesg_;
}
inline ::qihoo::protocol::messages::Proxy* Message::release_proxy_mesg() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Message.proxy_mesg)
  clear_has_proxy_mesg();
  ::qihoo::protocol::messages::Proxy* temp = proxy_mesg_;
  proxy_mesg_ = NULL;
  return temp;
}
inline void Message::set_allocated_proxy_mesg(::qihoo::protocol::messages::Proxy* proxy_mesg) {
  delete proxy_mesg_;
  proxy_mesg_ = proxy_mesg;
  if (proxy_mesg) {
    set_has_proxy_mesg();
  } else {
    clear_has_proxy_mesg();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.proxy_mesg)
}

// optional uint64 client_data = 11;
inline bool Message::has_client_data() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Message::set_has_client_data() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Message::clear_has_client_data() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Message::clear_client_data() {
  client_data_ = GOOGLE_ULONGLONG(0);
  clear_has_client_data();
}
inline ::google::protobuf::uint64 Message::client_data() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.client_data)
  return client_data_;
}
inline void Message::set_client_data(::google::protobuf::uint64 value) {
  set_has_client_data();
  client_data_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.client_data)
}

// optional string sender_type = 12;
inline bool Message::has_sender_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_sender_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_sender_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_sender_type() {
  sender_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sender_type();
}
inline const ::std::string& Message::sender_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.sender_type)
  return sender_type_.GetNoArena();
}
inline void Message::set_sender_type(const ::std::string& value) {
  set_has_sender_type();
  sender_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.sender_type)
}
#if LANG_CXX11
inline void Message::set_sender_type(::std::string&& value) {
  set_has_sender_type();
  sender_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.Message.sender_type)
}
#endif
inline void Message::set_sender_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sender_type();
  sender_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Message.sender_type)
}
inline void Message::set_sender_type(const char* value, size_t size) {
  set_has_sender_type();
  sender_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Message.sender_type)
}
inline ::std::string* Message::mutable_sender_type() {
  set_has_sender_type();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.sender_type)
  return sender_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_sender_type() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Message.sender_type)
  clear_has_sender_type();
  return sender_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_sender_type(::std::string* sender_type) {
  if (sender_type != NULL) {
    set_has_sender_type();
  } else {
    clear_has_sender_type();
  }
  sender_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sender_type);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.sender_type)
}

// optional string sender_jid = 13;
inline bool Message::has_sender_jid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_sender_jid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_sender_jid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_sender_jid() {
  sender_jid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sender_jid();
}
inline const ::std::string& Message::sender_jid() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.sender_jid)
  return sender_jid_.GetNoArena();
}
inline void Message::set_sender_jid(const ::std::string& value) {
  set_has_sender_jid();
  sender_jid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.sender_jid)
}
#if LANG_CXX11
inline void Message::set_sender_jid(::std::string&& value) {
  set_has_sender_jid();
  sender_jid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:qihoo.protocol.messages.Message.sender_jid)
}
#endif
inline void Message::set_sender_jid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sender_jid();
  sender_jid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Message.sender_jid)
}
inline void Message::set_sender_jid(const char* value, size_t size) {
  set_has_sender_jid();
  sender_jid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Message.sender_jid)
}
inline ::std::string* Message::mutable_sender_jid() {
  set_has_sender_jid();
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.sender_jid)
  return sender_jid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_sender_jid() {
  // @@protoc_insertion_point(field_release:qihoo.protocol.messages.Message.sender_jid)
  clear_has_sender_jid();
  return sender_jid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_sender_jid(::std::string* sender_jid) {
  if (sender_jid != NULL) {
    set_has_sender_jid();
  } else {
    clear_has_sender_jid();
  }
  sender_jid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sender_jid);
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.sender_jid)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace messages
}  // namespace protocol
}  // namespace qihoo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CommunicationData_2eproto__INCLUDED
